### 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

**관계형 데이터베이스**:고정된 행과 열로 구성된 테이블로 데이터를 저장한다.
- 각 열은 하나의 속성에 대한 정보를 저장하고, 행에는 각 열의 데이터 형식에 맞는 데이터가 저장
- 관계형 데이터베이스에서는 테이블의 구조와 데이터 타입 등을 사전에 정의한다.
- 테이블에 정의된 내용에 알맞은 형태의 데이터만 삽입할 수 있다.
- 특정한 형식을 지키기 때문에, 데이터를 정확히 입력했다면 데이터를 사용할 때는 매우 수월하다.
- SQL 문에 의해 관리되며 JOIN을 통해서만 연관관계가 가능하다.
- 관계형 데이터베이스 관리 시스템(RDBMS): Mysql, Oracle, Mssql, PostgresSQL 
- 장점 
  1) 데이터의 성능이 일반적으로 좋아 정력, 탐색, 분류가 빠르다
  2) 신뢰성이 높아 데이터의 무결성을 보장한다
  3) 정규화에 따른 갱신 비용을 최소화한다
- 단점
  1) 기존 작성된 스키마를 수정하기 어렵다
  2) 데이터베이스의 부하를 분석하기 어렵다
  3) 빅데이터를 처리하는 데 매우 비효율적이다
- 위 장단점을 고려했을 때 관계형 데이터베이스를 사용해야 하는 경우는 
  데이터베이스의 ACID 성질을 준수해야 하는 경우, 소프트웨어에 사용되는 데이터가 구조적이고 일관적인 경우 등이 있다

**비관계형 데이터베이스**: 비관계형 데이터베이스란 관계형 데이터베이스를 뺀 나머지 유형을 총칭(주로 데이터가 고정되어 있지 않은 데이터베이스)
- NoSQL 데이터베이스는 데이터 모델에 따라 유형이 다양하며 주요 유형으로는 문서, 키 값, 와이드 컬럼, 그래프가 있다.
- NoSQL에 스키마가 반드시 없는 것은 아니며, 이들은 유연한 스키마를 제공하며, 대량의 데이터와 높은 사용자 부하에서도 손쉽게 확장이 가능하다.
- NoSQL에서는 데이터를 읽어올 때 스키마에 따라 데이터를 읽어 온다.(이런 방식을 ‘schema on read’라고도 한다.)
- 종류에는 MongoDB, CouchDB 등이 있다.
- 장점
  1) 대용량 데이터 처리를 하는데 효율적이다
  2) 읽기 작업보다 쓰기 작업이 더 빠르고 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 빠르다
  3) 데이터 모델링이 유연하다
  4) 뛰어난 확장성으로 검색에 유리하다
  5) 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어나다
  6) 복잡한 데이터 구조를 표현할 수 있음.
- 단점
  1) 쿼리 처리 시 데이터를 파싱 후 연산해야해서 큰 크기의 document를 다룰 때는 성능이 저하
- 위 장단점을 고려했을 때 비관계형 데이터베이스를 사용해야 하는 경우는 데이터의 구조가 거의 또는 전혀 없는 대용량의 데이터를 저장하는 경우,  클라우드 컴퓨팅 및 저장공간을 최대한 활용하는 경우, 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트하는 경우 등이 있다.

### 2. 트랜잭션(transaction)이란 무엇인가요?

- **트랜잭션**이란 데이터베이스의 논리적 연산 단위(분할할 수 없는 최소 단위)이며, 밀접히 관련되어 분리될 수 없는 한 개 이상의 데이터베이스 조작을 가리킨다.
- 트랜잭션의 특성
  1) 원자성(atomicity): 트랜잭션에서 정의된 연산들은 모두 성공적으로 실행되거나 전혀 실행되지 않는 상태로 남아 있어야 한다(all or nothing)
  2) 일관성(consistency):트랜잭션이 실행되기 전의 데이터베이스 내용이 잘못되어 있지 않다면 트랜잭션이 실행된 이후에도 데이터베이스의 내용에 잘못이 있으면 안 된다.
  3) 고립성(isolation):트랜잭션이 실행되는 도중에 다른 트랜잭션의 영향을 받아 잘못된 결과를 만들어서는 안 된다.
  4) 지속성(durablility):트랜잭션이 성공적으로 수행되면 그 트랜잭션이 갱신한 데이터베이스의 내용은 영구적으로 저장된다.
- TCL(TRANSACATION CONTROL LANGUAGE)
  1) COMMIT: 올바르게 반영된 데이터를 데이터베이스에 반영시키는 것
  2) ROLLBACK: 트랜잭션 시작 이전의 상태로 되돌리는 것
  3) SAVEPOINT: 저장점 기능
 

### 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- **조인**이란 하나의 데이터베이스 내의 두 개 이상의 테이블들의 레코드를 연결 또는 결합하여 하나의 열로 표현(데이터 출력)하는 것

- JOIN 방식
  1) EQUI JOIN: 두 개의 테이블 간에 칼럼값들이 서로 정확하게 일치하는 경우에 사용되는 방법
     - 대부분 PK<->FK 의 관계 기반으로 한다(그러나 반드시  PK<->FK 의 관계로만 성립되는 것은 아니다
  2) Non EQUI JOIN: 두 개의 테이블 간에 칼럼값들이 서로 정확하게 일치하는 않는 경우 사용
     - Non EQUI JOIN의 경우에는 '='연산자가 아닌 다른(Between,>,>=,<,<=등) 연산자들을 사용하여 JOIN 수행
     - INNER JOIN에 속함
  3) INNER JOIN: JOIN 조건에서 동일한 값이 있는 행만 반환
     - CROSS JOIN, OUTER JOIN 에는 사용할 수 없으나, USING 조건절이나 ON 조건절에는 필수적으로 사용
  4) NATURAL JOIN: 두 테이블 간의 동일한 이름을 갖는 모든 칼럼에 대해 EQUI(=) JOIN을 수행
     - USING 조건절이나 ON 조건절, WHERE절에서 JOIN 조건을 정의할 수 없다.
     - JOIN에 사용된 칼럼들은 같은 데이터 유형이어야 한다
  5) CROSS JOIN: JOIN 조건이 없는 경우 생길 수 있는 모든 데이터의 조합
     - CARTESIAN JOIN은 CROSS JOIN의 종류로 조건이 없다.
     - CROSS JOIN 대신 콤마를 사용한다면 COMMA JOIN
  6) OUTER JOIN: JOIN 조건에서 동일한 값이 없는 행(NULL)도 출력
     - LEFT OUTER JOIN: JOIN 수행 시 우측 테이블에 해당하는 데이터를 먼저 읽은 후, 우측 테이블에서 JOIN 대상 데이터를 읽어온다
     - RIGHT OUTER JOIN: JOIN 수행 시 우측 테이블에 해당하는 데이터를 먼저 읽은 후, 좌측 테이블에서 JOIN 대상 데이터를 읽어온다
     - FULL OUTER JOIN: LEFT, RIGHT 모두 읽어온다(합집합 개념)
  7) SELF JOIN: 자기 자신을 조인
 
### 4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스란 데이터 저장(INSERT, UPDATE, DELETE)의 성능 희생과 추가 공간을 할당하는 대신에 데이터의 읽기 속도를 높이는 테이블의 동작 속도(조회)를 높여주는 자료구조이다.
- 데이터 조회가 많은 경우에 적합하지만, 데이터 변경이 많은 경우에는 오히려 성능이 감소할 수도 있다.
- 인덱스 알고리즘 종류
  1) B-Tree 인덱스는 칼럼의 값을 변형하지 않고, 원래의 값을 이용해 인덱싱하는 알고리즘
     - 장점:어떤 데이터를 조회하거나 사용하는 조회과정의 길이 및 비용이 균등
     - 단점: 데이터 조회하는 과정 대비 속도가 느리다
  2) Hash 인덱스 알고리즘은 칼럼의 값으로 해시값을 계산해서 인덱싱하는 알고리즘
     - 장점: 실제 키값과 관계없이 인덱스 크기가 작고 검색이 빠르며, 해시 인텍스 저장되는 값이 4~8바이트 수준이기에 조회 속도가 매우 빠르다
     - 각 해쉬값에 주소값을 배정하는 인덱스의 특징에 따라 위로 조회하는 작업은 느리다.
  3) Fractal-Tree 알고리즘은 B-Tree의 단점을 보완하기 위해 고안된 알고리즘 
- 인덱스 타입의 종류
  1) Primary(클러스터) 인덱스: 특정 나열된 데이터들을 일정 기준으로 정렬해주는 인덱스(ex. 영어사전)
     - 클러스터형 인덱스 생성 시 데이터 전체가 다시 정렬
     - 한 개의 테이블에 한 개씩만 만들 수 있다(ex : Primary Key)
     - 클러스터 인덱스는 따로 저장하는 정보 공간을 적게 사용하면서 테이블 공간 자체를 활용
     - 보조 인덱스보다 검색 속도가 빠르나 입력/수정/삭제는 느리다
     - MySQL에서는 Primary Key가 있다면 Primary Key를 Clustered INDEX로, 없다면 UNIQUE 하면서 NOT NULL인 컬럼을, 그것도 없으면 임의로 보이지 않는 컬럼을 만들어 Clustered Index로 지정  (Primary Key > UNIQUE 하면서 NOT NULL인 컬럼 > 임의로 보이지 않는 컬럼)
  2) 보조 인덱스(Secondary Index)
     - 후보키에만 부여할 수 있는 인덱스
       (후보키 : 고유 식별 번호, 주민번호 같이 각 데이터를 인식할 수 있는 최소한의 고유 식별 속성 집합)
     - 보조 인덱스의 생성 시에는 데이터 페이지는 그냥 둔 상태에서 별도의 페이지에 인덱스를 구성하기에 자동 정렬은 하지 않는다.
     - 보조 인덱스는 여러 개 생성할 수 있다. 
