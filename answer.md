# 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- **rdbms란, 특징**
    - 관계형 데이터 모델을 기반으로 구조화된 데이터베이스를 뜻한다.
    - 데이터는 릴레이션(관계)로 구성되고 각 관계는 순서 없는 튜플의 모음으로 구성된다.
    - 데이터 무결성을 보장한다.
    - 확장에 유연하지 못하며, 과도한 join 연산으로 성능이 하락할 수 있다.
- **nosql란, 특징**
    - 기존 rdb에서 사용하는 릴레이션과 튜플로 데이터를 관리하는 것이 아닌 유연한 스키마를 통해서 데이터를 구조화한 데이터베이스를 뜻한다.
    - 관계형 데이터베이스 대비 유연한 스키마를 제공하기 때문에 확장에 유리하다.
    - 유연한 구조를 채택했기 때문에 데이터 중복이 발생할 수 있다.
- **왜 nosql의 등장하게 되었는가?**
    - rdb는 엄격한 스키마를 지키기 때문에 확장에 불리하다.
    - 비정형 데이터의 증가로 인해 기존 테이블 스키마를 수정하면서 요구사항을 감당하기 힘들어졌다.
    - 이러한 요구사항을 해결하기 위해서 등장한 것이 NoSQL이다.
- **그럼에도 왜 rdb는 아직도 사용되고 있는가?**
    - 빈번한 join 연산은 역정규화를 통해서 줄일 수가 있다.
    - 항상 모든 경우가 수평적 확장이 필요한 것은 아니다. 쿼리를 읽기와 쓰기 쿼리를 분산하여 처리할 수도 있다.
    - 데이터 무결성이 매우 엄격한 비지니스에서는 rdb가 유용하다. (예 : 금융)

# 2. 트랜잭션(transaction)이란 무엇인가요?

- **트랜잭션 정의, 목적**
    - 트랜잭션은 데이터를 변경하기 위한 연산들의 집합이다.
    - 트랜잭션은 ACID를 보장하기 때문에 프로그래머는 애플리케이션 오류 처리를 단순하게 처리할 수 있다.
    - 원자성 : 트랜잭션은 DB에 완전 반영이 되거나, 완전히 이전 상태로 돌아가야 한다.
    - 일관성 : 트랜잭션 처리된 데이터는 항상 일관성이 유지되어야 한다.
    - 독립성 : 각 트랜잭션은 서로의 처리에 영향을 주지 않고 독립적이다.
    - 지속성 : 트랜잭션 처리는 데이터베이스에 영구적으로 반영이 된다.
- **트랜잭션 고려 사항**
    - DBMS는 여러 트랜잭션을 처리해서 처리율을 높힐 필요가 있다.
    - 여러 트랜잭션들이 같은 row를 작업할 수 있기 때문에 이러한 동시성 문제를 제어할 필요가 있다.
    
    |  | shared lock | exclusive lock |
    | --- | --- | --- |
    | shared lock | 공유 가능 | 공유 불가 |
    | exclusive lock | 공유 불가 | 공유 불가 |
    - 공유 락은 row를 조회할 때 사용하는 락이다. A 트랜잭션이 조회를 하고 있을 때, B 트랜잭션이 공유락 row에 접근할 경우 B 트랜잭션은 대기 상태가 된다. 이는 조회 중인 트랜잭션의 데이터 일관성을 보장하기 위해서 사용한다.
    - 베타 락은 row를 읽고 쓰기 작업을 할 때 사용하는 락이다. 베타적 권한을 보장하기 때문에 하나의 트랜잭션만 row에서 작업할 수 있다.
- **이상현상과 트랜잭션 고립 수준**
    - 트랜잭션은 최종적으로 commit과 rollback을 통해서 결과가 반영된다.
    - 여러 트랜잭션들이 작업을 처리하고 commit과 rollback을 진행하는데, 이 때 발생할 수 있는 현상을 이상현상이라고 한다.
    - SQL-92에서 명시된 이상현상은 Dirty Reads, Non-repeatable read, phantom reads가 존재한다.
    - Dirty Reads
    - ![dr](https://user-images.githubusercontent.com/20836023/216294113-44fc276f-79f7-4562-8cf3-93a50f66339f.png)

        - 커밋이 안된 데이터를 읽었을 때 발생하는 이상현상이다. 다른 트랜잭션에 의해 수정이 발생할 경우 데이터를 읽은 트랜잭션은 데이터의 일관성을 보장할 수 없게 된다.
    - Non-repeatable reads
    - ![nr](https://user-images.githubusercontent.com/20836023/216294132-4d866449-aa12-435b-ba28-95e798f4cb58.png)

      - 1차로 읽은 데이터가 다른 트랜잭션에 의해 커밋이 되어 변경이 발생했다면, 2차로 읽었을 때 다른 결과를 읽게 되는 이상 현상이다.
    - Phantom reads
    - ![pr](https://user-images.githubusercontent.com/20836023/216294170-bb6e3f6c-d40b-4e04-b362-2a20a4ca8047.png)
        - 범위 질의를 했을 때 읽은 결과(데이터의 수)가 다른 트랜잭션에 의해 새로운 row가 추가되어서 다시 읽었을 때 결과가 다른 이상현상이다.
    - 위에서 발생하는 이상 현상을 고립 수준으로 나누어 프로그래머가 선택할 수 있다.
    
    |  | Dirty read | Non-repeatable read | Phantom read |
    | --- | --- | --- | --- |
    | Serializable | no | no | no |
    | Repeatable read | no | no | yes |
    | Read committed | no | yes | yes |
    | Read uncommitted | yes | yes | yes |
    - 왜냐하면 모든 비지니스에서 높은 고립 수준을 필요하지 않기 때문이다. 높은 고립 수준은 엄격한 동시성 제어를 보장하지만, 처리율이 떨어지게 된다.
- **MySQL이 구현한 MVCC (Snapshot Isolation)**
    - 트랜잭션을 동시성 제어를 위해서는 lock을 사용한다. 하지만 lock을 사용하지 않고 트랜잭션마다 특정 시점의 테이블 복사본을 이용하여 동일한 결과를 얻을 수 있다.
    - lock을 사용하지 않기 때문에 읽기 처리율을 높힐 수 있다.
- **MySQL에서 사용하는 Next-key Lock**
    - MySQL은 repeatable read 고립 수준에서 phantom read를 방지할 수 있다. 이는 row 단위 lock과 범위 lock을 조합한 next-key lock을 사용하기 때문이다.

# 3. 1. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- Join이란? Join의 종류
    - rdb는 정규화를 통해서 릴레이션의 이상현상을 방지할 수 있다.
    - 하나의 릴레이션을 여러 릴레이션으로 분리하여 필요한 데이터를 조회할 때 Join 연산을 사용해서 다시 조합한다.
    - Inner Join
        - A 릴레이션과 B 릴레이션의 조인 컬럼 값이 양쪽 테이블에 공통적으로 존재할 경우에만 데이터를 추출하는 연산이다.
    - Left outer join
        - A 릴레이션과 B 릴레이션의 조인 컬럼 값이 양쪽 테이블에 공통적으로 존재할 때, 왼쪽 테이블 기준으로 컬럼을 합치는 Join 연산이다.
        - 만약 join 컬럼이 존재하지 않는 경우에는 null 값으로 채워진다.
    - Right outer join
        - A 릴레이션과 B 릴레이션의 조인 컬럼 값이 양쪽 테이블에 공통적으로 존재할 때, 오른쪽 테이블 기준으로 컬럼을 합치는 Join 연산이다.
        - 만약 join 컬럼이 존재하지 않는 경우에는 null 값으로 채워진다.
    - Full outer join
        - A 릴레이션과 B 릴레이션의 조인 컬럼 값이 양쪽 테이블에 공통적으로 존재할 때, 한쪽 테이블에 존재하는 모든 결과를 합치는 Join 연산이다.
- mysql에서 조인을 하는 방법
    - nested loop join
        - 2개 이상의 테이블에서 하나의 집합을 기준으로 Row를 결합하여 결과를 조합하는 방식이다. 프로그래밍 언어에서 중첩 for 문과 유사한 연산 과정을 거친다.
        - Driving table : 바깥에 있는 join 컬럼을 주도하는 테이블이다.
        - Driven table : 안쪽에 있는 테이블로 driving table에 의해 일치하는 컬럼이
    - hash join
        - 두 테이블 중 하나를 해시 테이블로 선정하여 조인될 테이블의 조인 키 값을 O(1)의 속도로 접근할 수 있는 조인 방법이다.
    - sort merge join
        - 양쪽 테이블을 각각 접근하여 그 결과를 정렬하여 다시 차례로 scan하여 merge하는 방식
        - 조인 조건의 컬럼에 인덱스가 없는 경우, 조회 범위가 좁을 경우 사용하는 방식이다.
- 각 조인마다 장단점
    - nested loop join의 장단점
        - 세컨더리 인덱스는 랜덤 I/O로 동작하기 때문에 대규모 데이터 처리에는 부적절하다.
        - Driving table은 데이터가 적거나 row의 숫자를 줄일 수 있는 where 조건이어야 한다.-
    - hash join의 장단점
        - 인덱스가 없어도 hash table 생성을 통해서 빠른 join 속도를 보장한다.
        - ‘=’ 비교를 통한 조인에 적합한 방식이다. 주로 대용량 데이터를 조인할 때 사용한다.
        - hash 함수와 hash table을 생성하기 때문에 컴퓨팅 자원을 많이 소모한다.
    - sort merge join
        - scan 후 merge하기 때문에 조인 컬럼 인덱스가 없어도 빠른 속도를 보장한다.
        - >, < 와 같은 범위 비교 연산에 사용하는 경우 적합하다.
        - 조인 컬럼이 이미 정렬이 되었다면 빠른 속도를 얻을 수 있다.
        - 만약 두 테이블 중 하나라도 정렬 작업이 종료가 안될 경우, 다른 테이블은 대기하게 된다.

# 4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스란?
    - 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조
- 인덱스 구조
    - 많은 데이터베이스 시스템에서 index는 b-tree 구조를 사용한다.
    - hash index
        - hash index는 빠른 데이터 접근 O(1)이 필요할 때 유용하다.
        - ‘=’ 연산은 매우 빠른 속도로 보장하나, ‘<, >’ 범위 연산을 할 경우 검색 범위를 좁힐 수가 없어 비효율적이다.
- b-tree 구조
    - 최상위 노드를 루트 노드라고 한다.
    - 중간에 위치한 노드들을 브랜치 노드라고 한다.
    - 맨 말단에 위치한 노드를 리프 노드라고 한다.
    - 하나의 노드에 매달린 자식 노드는 2개 이상 가능하다.
    - Key-Value 값들은 Key를 기준으로 항상 오름차순으로 정렬되어 있다.
    - 균형 트리(Balanced Tree)로 루트 노드에서 리프 노드까지의 거리가 모두 동일
    - 부등호 연산에 유리하다.
    - 데이터 탐색뿐 아니라, 저장, 수정, 삭제에도 항상 O(logN)의 시간 복잡도를 가진다.
    - Insert, Update, Delete 연산에 따라 b-tree를 재정렬할 필요가 있다. 이는 데이터베이스 성능에 영향을 준다.
 
 
![image](https://user-images.githubusercontent.com/20836023/216292700-4db6ebfa-f6b1-4e1a-bb8c-b0aa7d0cdbe0.jpeg)


- 인덱스를 사용하는 이유
    - MySQL은 인덱스를 버퍼 풀에 올려서 빠르게 접근할 수 있다.
    - 빈번한 I/O 접근을 줄일 수 있고 인덱스를 통해서 빠르게 검색 범위를 줄일 수 있다.
- 인덱스의 종류
    - 클러스터형 인덱스
        - primary key로 지정하면 자동으로 클러스터형 인덱스가 생성된다.
        - 유니크 인덱스가 있다면 유니크 인덱스 기준으로 정렬된다.
        - 아무런 인덱스가 없다면 MySQL은 임의로 키를 생성해서 정렬한다.
        - 테이블당 하나만 생성 가능
        - 행 데이터를 인덱스로 지정한 열에 맞춰서 자동으로 정렬함
        - 정렬 기준이 순차적이지 않다면 빈번한 레코드 구조 변경이 발생한다.
    - 논 클러스터형 인덱스 (세컨더리 인덱스)
        - 리프 노드의 주소 값이 실제 레코드 값이 아닌 클러스터 인덱스의 컬럼 값이다
        - 세컨더리 인덱스 통해서 검색할 때, 클러스터 인덱스를 다시 한번 거치는 과정이 필요하다.
- 인덱스의 장단점
    - 인덱스는 저장공간과 좁힐 수 있는 조회 범위에 따라 trade-off가 있다.
    - 장점
        - 빈번한 조회를 하는 컬럼 값은 인덱스가 있을 경우 빠른 조회가 가능하다.
        - 데이터 수정빈도가 낮다면 효율적으로 동작한다.
    - 단점
        - 추가적인 저장 공간이 필요하다.
        - Insert, Update, Delete 연산이 빈번할 경우 btree를 밸런싱하는 추가 작업이 필요하다.
- 효율적인 인덱스 컬럼이란?
    - where 절에서 자주 사용되는, 수정 빈도가 낮은, 카디널리티가 높고, 선택도가 낮은 컬럼이 효율적이다.

## 참고자료

Abraham Silberschatz, Henry F. Korth, S. Sudarshan, 데이터베이스 시스템, 정연돈, 권준호 역 외 3명, (한빛아카데미, 2021)

백은빈, 이성욱 저,  Real MySQL 1권 개발자와 DBA를 위한 MySQL 실전 가이드, (위키북스, 2021)

Martin Kleppmann, 데이터 중심 애플리케이션 설계, 정재부, 김영준, 이도영 역, (위키북스, 2018)

