# 백엔드 리온보딩 about MySQL
- 해당 답변은 구글링 결과와 ChatGPT 의 답변을 바탕으로 작성하였습니다. 

## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 답변전략
  - 1-1 데이터베이스
  - 1-2 관계형의 의미
  - 1-3 비관계형 데이터베이스
  - 1-4 장단점 비교와 Best Pratice

#### 1-1 데이터베이스
- 데이터베이스 설명 전에 생략된 단어를 전부 풀어서 쓰면 `데이터베이스 소프트웨어 프로덕트` 라고 생각합니다. 
- 데이터를 Create, Read, Write, Delete 할수 있는 소프트웨어는 모두 데이터 베이스(소프트웨어 프로덕트)입니다. 

#### 1-2 관계형의 의미

- 관계형(relational)은 데이터가 구성되고 서로 관련되는 방식인데요. 데이터끼리 관계가 있어서 관계형입니다
- 관계형 데이터베이스에서 데이터는 스프레드시트와 유사하게 행과 열이 있는 테이블로 구성됩니다. 이러한 테이블의 데이터 간의 관계는 서로 다른 테이블의 관련 데이터 간의 포인터 역할을 하는 키를 사용하여 설정됩니다.
- 예를 들어 도서관의 데이터베이스에는 책에 대한 테이블 하나와 저자에 대한 다른 테이블이 있을 수 있습니다. 두 테이블 간의 관계는 고유한 저자 ID를 통해 설정할 수 있습니다. 이 ID는 두 테이블 모두에 나타나며 데이터베이스가 각 저자와 책을 연결할 수 있도록 합니다.
- 데이터베이스에서 데이터를 구성하고 관련시키는 이러한 접근 방식은 복잡한 데이터 구조 및 관계를 모델링하는 강력하고 유연한 방법을 제공하며 많은 애플리케이션에서 가장 널리 사용되는 데이터베이스 모델이 되었습니다.

#### 1-3 비관계형 데이터베이스 

- 관계형/비관계형은 data structure 에 따른 분류입니다.
- 비관계형 데이터베이스는 관계형 데이터베이스가 아닌 다른 모든 데이터베이스를 묶어서 부르는 이름인데여
- 관계형 모델을 사용하지는 않는데, 이런 비관계형 데이터베이스의 일반적인 유형은 다음과 같습니다.
  - Document : 데이터를 JSON 또는 XML 같은 문서로 저장
  - Key-Value : 데이터를 키-값 쌍의 모음으로 저장
  - Column-family : 데이터를 행이 아닌 열 모음으로 저장
  - Graph : 데이터를 노드와 에지로 저장
  - Time-series

#### 1-4 장단점 비교와 Best Pratice

- 앞에서 제시한대로 관계형/비관계형은 data structure(자료구조) 에 관한 이야기이므로, 

|종류|장점|단점|함께해서 좋은곳
|------|---|---|---|
|relational|CRUD 모든 방면에서 적당한 성능, 트랜잭션|scale-out 어려움, 관계가 정해져있기 때문에 유연하지않고, 서비스가 고도화되면서 필연적이로 관계가 복잡해짐| 데이터 정규화가 강제된다는게 장점이자 단점. 대부분의 OLTP 서비스
|Document|정규화를 하지않는게 장점이자 단점, scale-out적당 |트랜잭션 곤란, ACID 제한적 | json, 정규화하기 힘든 텍스트데이터
|Key-Value | Map자료구조라서 모델이 단순, CRUD 모두 빠름 | 보조인덱스 활용 불가능, Key가 유일한 검색조건 |
|Column-family  | 수평확장이 가능, 통계 등 대용량 데이터에서 인사이트를 얻을때 유리 | 아무리 적게잡아도 최소 천만건 이상부터 쓸만해서 대부분의 경우에 일로 만난사이라는게 단점 | 관계형 대이터베이스의 complementarity 한 관계임 >> 비슷한거같은데 완전 반대라서 상호보완적임..?
|Graph |  |  | 안써봐서 모르고 찾아봐도 모르겠습니다
|Time-series  |  |  | 센서값 같이 시간에 따라 변화하는 추이를 볼때 적당함 : 네비앱의 GPS raw data






-----------------------

## 2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션이란 여러단계의 작업들을 하나의 동작으로 묶어주는 기능입니다. 
- 하나의 트랜잭션 내부에서는 내부의 여러 단계의 작업중 하나가  실패하더라도 트랜잭션 전체를 실패로 인식하기 때문에 데이터베이스가 일관된 상태를 유지할수 있습니다.
- 데이터베이스 작업이 특정 순서로 실행되어야 할때 순서를 보장하기도 하며, 모든 작업이 성공하거나 모든 작업이 실패할수 있도록 묶어줍니다.
- 트랜잭션에서 성능-데이터 안정성 사이의 Tread-off 수준을 결정하는 전략으로 `isolation level`, `optimistic and pessimistic locking`이 있습니다




-----------------------

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인은 관련 열을 기반으로 여러 테이블의 데이터를 결합하는 기능입니다.
- SQL에서 조인의 역할은 마치 단일 테이블인 것처럼 여러 테이블에서 데이터를 검색할 수 있도록 해줍니다.
- 조인 방법은 아래와 같습니다
  - INNER JOIN
    - : 두 테이블 모두 일치하는 행만 반환합니다. 두 테이블에서 일치하는 값이 있는 행만 반환합니다.
  - LEFT JOIN(또는 LEFT OUTER JOIN)
    - : 왼쪽 테이블(table1)의 모든 행과 오른쪽 테이블(table2)의 일치하는 행을 반환합니다. 결과에는 오른쪽에서 일치하지 않는 행에 대한 NULL 값이 포함됩니다.
  - RIGHT JOIN(또는 RIGHT OUTER JOIN)
    - : 오른쪽 테이블(table2)의 모든 행과 왼쪽 테이블(table1)의 일치하는 행을 반환합니다. 결과에는 왼쪽에서 일치하지 않는 행에 대한 NULL 값이 포함됩니다.
  - FULL OUTER JOIN
    - : 결합된 일치하는 행과 NULL 값을 포함하는 일치하지 않는 행을 포함하여 두 테이블의 모든 행을 반환합니다.
  - CROSS JOIN
    - : 두 테이블의 데카르트 곱을 반환합니다. 즉, 두 테이블에서 가능한 모든 행 조합을 반환합니다.
  - SELF JOIN
    - : 자기 테이블 자신과 조인되는 조인.


#### INNER JOIN:

```SQL
SELECT *
FROM table1
INNER JOIN table2
ON table1.column = table2.column;
```

#### LEFT JOIN:

```SQL
SELECT *
FROM table1
LEFT JOIN table2
ON table1.column = table2.column;
```

#### RIGHT JOIN:

```SQL
SELECT *
FROM table1
RIGHT JOIN table2
ON table1.column = table2.column;
```

#### FULL OUTER JOIN:

```SQL
SELECT *
FROM table1
FULL OUTER JOIN table2
ON table1.column = table2.column;
```

#### CROSS JOIN:

```SQL
SELECT *
FROM table1
CROSS JOIN table2;
```

#### SELF JOIN:

```SQL
SELECT *
FROM table1 t1
JOIN table1 t2
ON t1.column = t2.column;
```



-----------------------

## 4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스 답변전략
  - 인덱스 정의
  - 테이블 관점의 인덱스 
    - secondary index & primary index
  - 자료구조 관점의 인덱스
    - Clustered Index
    - fulltext index

### 인덱스 정의

- 인덱스란 : 데이터중 일부만 떼어내서 한번더 저장한 추가 데이터 입니다
  - 검색속도 향상을 위해서 존재하기 때문에, 탐색에 유리한 자료구조로 저장
  - Write 기능(INSERT, UPDATE, DELETE) 의 성능이 하락
  - Read 기능의 (SELECT) 성능을 높이는 기법

### 테이블 관점에서의 분류

- RDBMS 의테이블 입장에서는 
- 주인덱스 : Not null, Unique 제약조건이 강제되는 인덱스이며, Primary Column 를 대상으로 걸려있는 인덱스입니다
- 보조인덱스 : 제액조건은 따로 없고 사용자가 걸고싶은곳에 생성할수 있는 인덱스

### 자료구조 관점의 인덱스

- Clustered Index : 인덱스 순서와 테이블의 행(row) 정렬순서가 같은 인덱스
  - 각 행의 데이터가 해당 행의 인덱스 동일한 위치에 저장하기 떄문에. 데이터가 물리적으로 인덱스와 같은 위치에 저장되기 때문에 클러스터형 인덱스를 사용하는 쿼리는 그렇지 않은 쿼리보다 훨씬 빠르게 데이터를 검색할 수 있습니다.
  - index의 Key 를 알고 있으면 row 의 전체데이터 `select *` 같은 상황에서 제일 효율적인 인덱스 저장방식
  - MySQL의 InnoDB 스토리지 엔진에서 기본 PK인덱스로 자주 사용
  - 최적의 성능을 뽑아내려면 인덱스에 적합한 열을 선택하는 것이 중요한거같은데, 제 짧은 생각으로는
  ```
  OLTP 서비스에서는 자연키를 쓰지말고 인공키로 따로 만들어서 도메인로직이랑은 분리를 시켜줘야 좋은거같슴다..
  public 한 정보들은 bigint type의 Auto-Increment 로 알아서 1씩 증가하는 인공키를 사용 하는게 편한거같고 (예를들어 책정보, 가게정보, 창고정보, 메뉴정보 등등..)
  private 한 정보들은 random 값으로 인공키(UUID 같은..)를 추가하는게 편하다고 생각입니다 (예를들어 회원상세정보, 예약내역벊번호, 주문번호)
  ```

- fulltext index : 모든 문자열 데이터를 full-scan 하는 상황을 피하기 위해 만든 
  - 사용하는 종류로는 
  ```
  MyISAM 전체 텍스트 인덱스 : 좀 예전에 쓰던거..?
  InnoDB 전체 텍스트 인덱스 : Mysql 5.6 버전 이상에서 쓰는거
  ngram 전체 텍스트 인덱스
  ```
  - 초보라서 잘 모르는데 전문검색 틀린점 있으면 고견 부탁드리겠습니다..!
  - InnoDB full-text-indxe 와 ngram 간의 차이
  ```
  n-gram은 단어나 문장과 같은 주어진 텍스트 시퀀스에서 n개 항목의 서브셋을 모두 저장하는 기법
  
  n-그램 인덱스는 무엇보다도 퍼지 텍스트 일치 및 맞춤법 교정에 사용할 수 있습니다.
  
  장점>
  - 퍼지 텍스트 일치: N-그램을 사용하여 퍼지 텍스트 일치를 수행할 수 있으며, 이는 사용자 쿼리에 오타나 맞춤법 오류가 포함될 수 있는 시나리오에서 유용합니다.
  - 맞춤법 수정: N-gram은 쿼리에서 단어의 올바른 맞춤법을 제안하는 데 사용할 수 있습니다.
  - 효율적인 스토리지: N-gram은 상대적으로 스토리지 오버헤드가 적기 때문에 리소스가 제한된 환경에서 사용하기에 적합합니다.
  
  단점:
  - 정확성 감소: 일치 프로세스가 완전한 단어나 구문이 아닌 텍스트의 하위 시퀀스를 기반으로 하기 때문에 N-gram은 때때로 관련 없는 결과를 생성할 수 있습니다.
  ```
  
  ```
  InnoDB Full-Text Index는 InnoDB 스토리지 엔진에 내장된 인덱싱 기법으로 토큰화, 형태소 분석 및 불용어 제거를 포함한 다양한 기법 사용
  
  장점>
  - 향상된 검색 정확도: InnoDB 전체 텍스트 인덱스는 토큰화, 형태소 분석 및 불용어 제거와 같은 전체 텍스트 검색 결과의 정확도를 개선하기 위해 다양한 기술을 사용합니다.
  - 효율적인 검색: InnoDB 전체 텍스트 인덱스는 빠른 전체 텍스트 검색 성능에 최적화되어 있으며 많은 양의 텍스트 데이터를 처리할 수 있습니다.
  - InnoDB와의 통합: InnoDB Full-Text Index는 InnoDB 스토리지 엔진과 통합되어 매끄럽고 효율적인 전체 텍스트 검색 경험을 제공합니다.

  단점>
  - 리소스 요구 사항: InnoDB 전체 텍스트 인덱스는 n-gram 인덱스보다 더 많은 리소스가 필요하므로 리소스가 제한된 환경에는 적합하지 않을 수 있습니다.
  - InnoDB로 제한됨: InnoDB 전체 텍스트 인덱스는 InnoDB 스토리지 엔진 내에서만 사용할 수 있으므로 MySQL의 다른 스토리지 엔진과 함께 사용할 수 없습니다.
  ```
- 참고로 H2 에서는 전문검색엔진은 Apache Lucene 을 사용합니다 (NoSQL ES 에서 사용하는 그것..)




