1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

### (1) 특징

**데이터 저장(Storage)**
- 관계형: SQL을 이용하여 데이터를 `테이블`에 저장한다.
- 비관계형: `key-value, document, wide-column, grapth` 등의 방식으로 데이터를 저장한다.

**스키마(Schema)**
- 관계형: `고정된 형식의 스키마`가 필요하여 데이터 속성별로 열(cloumn)에 대한 정보(type)을 미리 정의해야 한다. 스키마를 변경할 수 있으나, 데이터베이스 전체를 수정하거나, 오프라인으로 전환이 필요하다.
- 비관계형: `동적으로 스키마 형태를 관리`할 수 있으며, 개별 속성에 대해 모든 열에 대한 데이터를 반드시 입력하지 않아도 된다.

**쿼리(Querying)**
- 관계형: 테이블의 형식과 테이블 간의 관계에 맞춰 데이터를 요청해야 하기 때문에, `SQL과 같이 구조화된 쿼리 언어를 사용`한다.
- 비관계형: 데이터 그룹 자체를 조회하는 것이기 때문에 `구조화 되지 않은 쿼리 언어로도 데이터 요청이 가능`하다.

**확장성(Scalability)**
- 관계형: `수직적으로 확장`한다. 높은 메모리, CPU를 사용하는 확장이라고도 하며, 하드웨어 성능을 많이 이용하기 때문에 비용이 많이 든다. 여러 서버에 걸쳐서 데이터베이스의 관계를 정의할 수 있으나, 매우 복잡하고 많은 시간이 소모 된다.
- 비관계형: `수평적으로 확장`한다. 보다 저렴한 서버 증설 또는 클라우드 서비스를 이용하는 확장이라고도 하며, 추가적인 서버 구축으로 많은 트래픽을 보다 편리하게 처리할 수 있다. 저렴한 범용 하드웨어나 클라우드 기반의 인스턴스에 비관계형 데이터베이스를 호스팅할 수 있어 수직적 확장보다 상대적으로 비용이 저렴하다.

<br/>

### (2) 예시
**관계형 데이터베이스를 사용하는 경우**
1. 데이터베이스의 `ACID` 성질을 준수해야 하는 경우: 하나의 트랜잭션(Transaction)에 의한 상태의 변화를 수행하는 과정에서 안전성을 보장하며, 데이터 처리 시 발생할 수 있는 예외적인 상황을 줄이고, 데이터베이스의 무결성을 보호한다.
2. 소프트웨어(프로젝트)에 사용되는 데이터가 `구조적이고 일관적`인 경우

**비관계형 데이터베이스를 사용하는 경우**
1. 데이터의 `구조가 거의 또는 전혀 없는 대용량의 데이터`를 저장하는 경우
2. `클라우드 컴퓨팅 및 저장공간을 최대한 활용`하는 경우
3. 빠르게 서비스를 구축하는 과정에서 `데이터 구조를 자주 업데이트` 하는 경우

<br/>
<br/>

---

<br/>
<br/>

2. 트랜잭션(transaction)이란 무엇인가요?

### (1) 정의
데이터베이스의 상태를 변환시키는 하나의 논리적 기능을 수행하기 위한 작업의 단위 또는 한번에 수행되어야 할 일련의 연산들

<br/>

### (2) 특징
**Atomicity(원자성)**
- 트랜잭션이 데이터베이스에 모두 반영되거나, 전혀 반영되지 않아야 한다.
- 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 모두가 완벽히 수행되지 않고 어느 하나라도 오류가 발생하면 트랜잭션 전부가 취소되어야 한다.

**Consistency(일관성)**
- 트랜잭션의 작업 처리 결과는 항상 일관성이 있어야 한다.
- 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 수행 완료 후의 상태가 같아야 한다.

**Isolation(독립성)**
- 2개 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도 다른 트랜잭션 연산에 끼어들 수 없다.
- 수행 중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없다. 

**Durability(지속성)**
- 트랜잭션이 성공적으로 완료되었을 경우, 결과는 영구적으로 반영되어야 한다.

<br/>

### (3) 연산
**Commit**
- 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성 있는 상태에 있을 때 하나의 트랜잭션이 끝났음을 알려주는 연산

**Rollback**
- 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 모든 연산을 취소하는 연산

<br/>

### (4) 상태
**활동(Active)**
- 트랜잭션의 활동 상태
- 트랜잭션이 실행중이며 동작중인 상태

**부분완료(Partially Committed)**
- 트랜잭션의 Commit 명령이 도착한 상태
- 트랜잭션의 Commit 이전 SQL문이 수행되고 Commit만 남은 상태
- Commit 명령이 도착한 상태이나, 문제없이 수행할 수 있다면 완료(Committed) 상태가 되며, 오류가 발생할 경우 실패(Failed) 상태

**완료(Committed)**
- 트랜잭션 완료 상태
- 트랜잭션이 정상적으로 완료된 상태

**실패(Failed)**
- 트랜잭션 실패 상태
- 트랜잭션이 더 이상 정상적으로 진행될 수 없는 상태

**취소(Aborted)**
- 트랜잭션 취소 상태
- 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태

<br/>

※ 트랜잭션 범위를 최소화해야 한다. 데이터베이스 커넥션의 개수는 제한적이기 때문에, 각 단위 프로그램이 커넥션을 소유하는 시간이 길어진다면 여유 커넥션 개수가 줄어들기 때문이다. 혹은 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수 있다.

<br/>
<br/>

---

<br/>
<br/>

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

### (1) 정의
2개 이상의 테이블을 묶어 하나의 결과 집합으로 만드는 것

### (2) 종류
**INNER JOIN**
- join하는 테이블의 on 절 조건이 일치하는 결과만 출력

**LEFT JOIN**
- 첫 번째 테이블을 기준으로 두 번째 테이블을 조합
- on 절 조건을 만족하지 않는 경우에 두 번째 테이블의 필드 값은 모두 null로 표시

**RIGHT JOIN**
- 두 번째 테이블을 기준으로 첫 번째 테이블을 조합
- on 절 조건을 만족하지 않는 경우에 첫 번째 테이블의 필드 값은 모두 null로 표시

**FULL OUTER JOIN**
- 첫 번째, 두 번째 테이블의 모든 데이터 검색

**CROSS JOIN**
- 모든 경우의 수의 데이터 조합

**SELF JOIN**
- 자기자신과의 조합

<br/>
<br/>

---

<br/>
<br/>


4. MySQL에서 인덱스(index)란 무엇인가요?

### (1) 정의
테이블의 column을 B+ Tree 구조로 색인화하여 검색 속도 향상

### (2) 인덱스 설정 기준
**카디널리티(Cardinality)**
- `높을수록` 인덱스 설정에 좋은 컬럼이다. 
- 한 컬럼이 갖고 있는 값의 `중복 정도가 낮을수록`(고유할 수록) 좋다.

**선택도(Selectivity)**
- `낮을수록` 인덱스 설정에 좋은 컬럼이다. 
- 특정 값을 얼마나 잘 선택할 수 있는지의 지표
- (컬럼의 특정 값의 row 수 / 테이블의 총 row 수 * 100) 또는 (컬럼 값들의 평균 row 수 / 테이블의 총 row 수 * 100)

**활용도**
- `높을수록` 인덱스 설정에 좋은 컬럼이다. 
- 실제 작업에 얼마나 활용되는지(쿼리를 날릴 때 WHERE 절에 얼마나 자주 활용 되는지)에 대한 값

**중복도**
- `없을수록` 인덱스 설정에 좋은 컬럼이다.

<br/>
<br/>
