## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

### 관계형 데이터베이스(RDBMS)

- 장점
  - 명확하게 정해진 스키마를 통해, 데이터 무결성을 보장한다.
  - 데이터간 관계를 통해, 데이터를 중복없이 저장할 수 있다.

- 단점
  - 명확하게 정해진 스키마로 인해, 스키마에 맞추어 데이터를 저장해야 하며, 기존의 스키마를 수정하기 어렵다.
  - 데이터간 관계로 인해 테이블이 많아지고 JOIN이 많아질경우 복잡한 쿼리가 발생될 수 있다.
  - 수평 확장이 어렵고 수직 확장만 가능하여 데이터 처리량을 늘리는데 한계가 있다.

### 비관계형 데이터베이스(NoSQL)
- 장점
  - 정해진 스키마가 없기때문에, 서로 다른 구조의 데이터를 동일한 컬렉션에 저장할 수 있다.
  - 수직 및 수평 확장이 가능해서 애플리케이션이 발생시키는 모든 읽기/쓰기 요청을 처리할 수 있다.

- 단점
  - 정해진 스키마가 없기 때문에, 명확한 데이터 구조를 보장하지 않고 데이터 구조 결정을 미루게 된다.
  - NoSQL마다 쿼리 언어를 다르게 사용하는 경우가 많아 이식성이 낮다 
  - 데이터가 중복되어 관리하기가 어렵다. 따라서 조인을 잘 사용하지 않고 자주 변경되지 않는 데이터일 경우 사용하는것이 좋다.

## 2. 트랜잭션(transaction)이란 무엇인가요?

- 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위로 작업의 완전성을 보장해주기 위한 기능이다. 논리적인 작업을 모두 완벽하게 처리하거나 처리하지 못할 경우 원상태로 북구하여 일부만 적용되는 현상을 막는다.
- 트랜젝션의 특징
  - 원자성 (Atomicity)  : 트랜젝션이 DB에 모두 반영되거나, 혹은 전혀 반영되지 않아야 된다.
  - 일관성(Consistency) : 트랜잭션의 작업 처리 결과는 항상 일관성 있어야 한다.
  - 독립성(Isolation) : 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
  - 지속성(Durability) : 트랜잭션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.
- Commit : 하나의 트랜잭션이 성공적으로 수행된경우 트랜잭션의 수정사항을 영구적으로 반영한다.
- RollBack : 트랜잭션이 비정상적으로 수행된경우 트랜잭션 수행 이전상태로 되돌린다.

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

두개 이상의 테이블을 결합하여 나타내는것

**종류**
- INNER JOIN : 교집합으로, 기준 테이블과 join 테이블의 중복된 값을 보여준다.
- LEFT OUTER JOIN : 기준테이블값과 조인테이블과 중복된 값을 보여준다. 왼쪽 테이블 기준으로 join한다.
- RIGHT OUTER JOIN : LEFT OUTER JOIN과는 반대로 오른쪽 테이블 기준으로 join한다.
- FULL OUTER JOIN : 합집합을 말한다. 각 테이블의 모든 데이터가 반환된다.
- CROSS JOIN : 두테이블의 곱집합을 반환한다.
- SELF JOIN : 자기자신과 자기자신을 조인하는 것이다.

## 4. MySQL에서 인덱스(index)란 무엇인가요?

데이터베이스의 추가적인 공간을 활용하여 테이블의 검색속도를 향상시켜주기 위한 자료구조이다.

데이터베이스의 모든 데이터를 순차적으로 탐색하여 데이터를 가져오려면 오랜 시간이 걸리기 때문에 칼럼의 값과 해당 레코드가 저장된 주소를 Key-Value형태로 정렬해서 보관해둔다.
검색속도를 향상시켜준다는 장점이 있지만, 인덱스를 위한 추가적인 공간이 필요하고 삽입 수정 삭제시 재정렬을 위한 시간이 추가적으로 필요하다는 단점이 있다.

### 인덱스의 종류
**클러스터링 인덱스**
- PK 값을 기준으로 비슷한 값끼리 묶어서 저장한다고 하여 클러스터링 인덱스라고 불린다.
- PK 값을 기준으로 물리적인 저장 위치를 결정한다.
- 클러스터링 인덱스의 리프노드에는 PK에 해당하는 모든 레코드의 데이터가 적재되어 있다.
- 클러스터링 인덱스의 값은 변경하지 않는것이 좋다.(변경시 레코드를 삭제하고 삽입하는 연산이 필요하다). 
- 모든 세컨더리 인덱스가 클러스터링 인덱스를 포함하고 있기 때문에 가능한 PK값을 작게 유지하는것이 좋다.
- PK 값을 명시하지 않을경우 INNODB내부적으로 일련번호를 생성한다. 이렇게 생성된 값은 사용자에게 보이지도 않고 접근할 수 없으므로 PK값은 가능한 지정해주는것이 좋다.
**세컨더리 인덱스**
- 프라이머리 키를 제외한 모든 인덱스를 세컨더리 인덱스라고 한다.
- 프라이머리 키 이외에 사용하고 싶은 검색조건이 있을경우 사용하면 성능향상을 기대할 수 있다.
- 세컨더리 인덱스의 리프노드에는 PK가 저장되어있다. 해당 PK값을 통해 클러스터링 인덱스에 접근하여 레코드 데이터를 가져오게 된다.

**인덱스 자료구조**
- Hash Tree: 삽입 수정 삭제를 모두 O(1)시간에 한다는 장점이 있다. 하지만 값을 변형해서 인덱싱하므로 전방(Prefix) 일치와 같이 값의 일부만 조회하거나 범위 조회시에는 해시 인덱스를 사용할 수 없다.
- B-Tree : 컬럼의 값을 변경하지 않고 원래의 값을 이용해 저장하는 알고리즘으로 가장 범용적으로 사용된다. 이진트리와 달리 하나의 노드에 많은수의 정보를 가지며, 각 노드의 키값보다 작은 값은 왼쪽, 큰 값은 오른쪽에 둔다. 데이터 조회뿐만 아니라 수정 삭제시에도 log N시간에 삭제 가능하다. 삽입 수정 삭제 작업이후 재정렬되는 작업으로 인해 추가적인 시간이 소모된다.
- B+Tree : B-Tree의 경우 루트노드, 브렌치 노드에도 데이터를 포함하고 있기 때문에 전체조회시 모든 노드를 방문해야 한다는 단점이 있다. B+Tree는 이러한 점을 개선하여 리프노드에만 데이터를 둔다. 리프노드는 LinkedList로 연결되어 있어 전체 조회시 선형시간에 전체 데이터를 조회할 수 있다는 장점이 있다. MySQL의 InnoDB는 B+Tree를 채택하고 있다.
