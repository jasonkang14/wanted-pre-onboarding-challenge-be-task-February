1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 관계형 데이터베이스는 "Relational DBMS"라는 말뜻과 같이 테이블 간의 관계가 중요한 데이터베이스이다. 반드시 스키마 규격에 맞춰서 데이터를 다뤄야하는데, 2차원 형식의 테이블에 속성과 값을 이용해 데이터를 정의하고 저장, 관리한다. 각 테이블은 Primary Key, Foreign Key, Index를 Column 별로 설정할 수 있다. 관계를 맺기 위해 외래키를 사용하고 이를 이용해 JOIN을 할 수 있다. 결과적으로 대용량의 데이터를 체계적으로 관리할 수 있다는 장점이 있다. 하지만 관계가 많아지고 시스템이 커질수록 JOIN문이 많은 복잡한 쿼리가 생길 수 있고, 스키마로 인해 데이터가 유연하지 못해 설계를 잘못했을 때 돌이키기 어렵다.

- 비관계형 데이터베이스(Not Only SQL)는 RDBMS와는 다르게 데이터와 테이블 간의 관계를 정의하지 않는다. 정해진 스키마가 없기 때문에 비교적 자유롭고 유연하다. 덕분에 추후에 새로운 필드를 추가하는 것이 훨씬 쉽다는 장점이 있다. 읽기와 쓰기라는 기본적인 기능에 충실해, 대용량의 데이터의 읽기와 쓰기에 강점을 가진다. 하지만, 데이터 중복이 발생할 수 있고 중복된 데이터를 변경하면 모든 컬렉션에서 수정을 해줘야한다. 또한, 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 정하는 것이 어려울 수 있다. 그 외에도 key 값만으로 데이터의 입출력을 지원한다는 점, 데이터의 update가 느리다는 단점이 있다.

2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단위를 말한다.

- 트랜잭션은 아래와 같은 4가지 특징이 있다.

  - 원자성(Atomicity): DB에 모두 반영되거나, 반영되지 않거나를 뜻한다.(All or Nothing) 트랜잭션에서 원자성은 수행하고 있는 트랜잭션에 의해 변경된 내역을 유지하면서, 이전에 커밋된 상태를 임시 영역에 따로 저장함으로써 보장한다. 현재 수행하고 있는 트랜잭션에서 오류가 발생하면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 롤백한다. (롤백과 커밋은 후에 설명)
  - 일관성(Consistency): 작업 처리의 결과가 항상 일관되어야 한다는 의미이다. 트랜잭션에서 일관성은 트랜잭션 수행 전/후에 데이터 모델의 모든 제약 조건(기본 키, 외래 키, 도메인, 도메인 제약조건 등)을 만족하는 것을 통해 보장한다.
  - 독립성(Isolation) 또는 고립성: 하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없고 마찬가지로 독립적임을 의미한다. 트랜잭션이 실행하는 도중에 변경한 데이터는 이 트랜잭션이 완료될 때까지 다른 트랜잭션이 참조하지 못하게 하는 특성이다. 데이터베이스는 클라이언트들이 같은 데이터를 공유하는 것이 목적이므로 여러 트랜잭션이 동시에 수행되어야 한다. 이때 트랜잭션은 상호 간의 존재를 모르고 독립적으로 수행되어야 한다.
  - 지속성(Persistance): 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 함을 뜻한다. 속성(durability)은 트랜잭션의 성공 결과 값은 장애 발생 후에도 변함없이 보관되어야 한다는 것으로 트랜잭션이 정상적으로 완료된 경우에는 버퍼의 내용을 하드디스크(데이터베이스)에 확실히 기록해야 하며, 부분 완료(Partial Commit)된 경우에는 작업을 취소(Aborted)하여야 한다. 이를 영속성이라고 표현하기도 한다.

- 트랜잭션의 연산 - Commit과 Rollback, 그리고 Save Point

  - 커밋(Commit): 커밋 연산은 모든 작업들을 정상적으로 처리하겠다고 확정하는 명령어로서, 처리과정을 데이터베이스에 영구적으로 저장하는 것이다. 커밋을 수행하면 하나의 트랜잭션 과정을 종료하는 것이다. 커밋을 수행하면 이전 데이터가 완전히 업데이트된다.
  - 롤백(Rollback): 롤백 연산은 작업 중 문제가 발생하여 트랜잭션의 처리과정에서 발생한 변경사항을 취소하는 명령어이다. 이 트랜잭션의 일부가 정상적으로 처리되더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소한다는 특징이 있다. 여기서 **롤백 세그먼트(rollback segment)**라는 것을 사용한다. 롤백 세그먼트란 이전 데이터들이 임시로 저장되는 영역인데, 오류가 발생하면 현재 내역을 날려버리고 임시 영역에 저장했던 상태로 롤백한다.
  - 부분저장(Save Point): 확실한 부분에 대해서는 롤백이 되지 않도록 중간 저장 지점인 세이브포인트(save point)를 지정할 수 있다. 세이브포인트를 쓰면 트랜잭션을 작게 분할하는 것이 가능하다. 세이브포인트는 여러 개의 SQL문을 실행을 수행하는 트랜잭션의 경우에 사용자가 트랜잭션 중간 단계에서 세이브포인트를 지정할 수 있다.

- 트랜잭션의 5가지 상태

  - 활동(Active) : 트랜잭션이 실행 중인 상태이다.
  - 실패(Failed) : 트랜잭션 실행에 오류가 발생하여 중단된 상태이다.
  - 철회(Aborted) : 트랜잭션이 비정상적으로 종료되어 롤백 연산을 수행한 상태이다.
  - 부분 완료(Partially Committed) : 트랜잭션의 마지막 연산까지 실행했지만, 커밋 연산이 실행되기 직전의 상태이다.
  - 완료(Committed) : 트랜잭션이 성공적으로 종료되어 커밋 연산을 실행한 후의 상태이다.

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- JOIN이란 스키마에서 설정해놓았던 외래키를 사용해 2개 이상의 테이블을 연결해 출력하는 것을 말한다.
- JOIN의 종류

  - INNER JOIN: JOIN 조건에서 동일한 값이 있는 행만 반환한다.(교집합)

  ```sql
  SELECT 테이블명1.컬럼명1, 테이블명2.컬럼명1
  FROM 테이블명1 INNER JOIN 테이블명2
  ON 테이블명1.컬럼명1, 테이블명2.컬럼명1;
  ```

  - OUTER JOIN: JOIN 조건에서 동일한 값이 없는 행도 반환할 때 사용한다. LEFT OUTER JOIN, RIGHT OUTER JOIN, FULL OUTER JOIN 등이 있다.

  - LEFT OUTER JOIN: 조인 수행 시 먼저 표기된 좌측 테이블에 해당하는 데이터를 먼저 읽은 후, 우측 테이블에서 JOIN 대상 데이터를 읽어온다.

  ```sql
  SELECT 컬럼명1, 컬럼명2
  FROM 테이블명1 LEFT OUTER JOIN 테이블명2
  ON 테이블명1.컬럼명1 = 테이블명2.컬럼명1;
  ```

  - RIGHT OUTER JOIN: 조인 수행 시 먼저 표기된 우측 테이블에서 해당하는 데이터를 먼저 읽은 후, 좌측 테이블에서 JOIN 대상 데이터를 읽어온다.

  ```sql
  SELECT 컬럼명1, 컬럼명2
  FROM 테이블명1 RIGHT OUTER JOIN 테이블명2
  ON 테이블명1.컬럼명1 = 테이블명2.컬럼명1;
  ```

  - FULL OUTER JOIN: 합집합을 말한다. 테이블 1과 테이블 2의 모든 데이터가 검색된다.

  ```sql
  SELECT 컬럼명1, 컬럼명2
  FROM 테이블명1 FULL OUTER JOIN 테이블명2
  ON 테이블명1.컬럼명1 = 테이블명2.컬럼명1;
  ```

  - NATURAL JOIN: 테이블 간 중복된 열이 있다면, 한개만 표시하는 JOIN 을 뜻한다.

  ```sql
  SELECT 컬럼명1, 컬럼명2
  FROM 테이블명1 NATURAL JOIN 테이블명2;
  ```

  - CROSS JOIN: 일반 집합 연산자의 PRODUCT 개념으로 테이블간 조인조건이 없는 경우 생길 수 있는 모든 데이터의 조합을 말한다. 두 개의 테이블에 대한 CROSS JOIN 결과는, 양쪽 집합의 M \* N 건의 데이터 조합이 발생한다.

  ```sql
  SELECT 컬럼명1, 컬럼명2
  FROM 테이블명1 CROSS JOIN 테이블명2;
  ```

  - SELF JOIN: 자기자신을 조인하는 것이다. 하나의 테이블을 여러번 복사해서 조인한다고 보면 된다.

  ```sql
  SELECT 컬럼명1, 컬럼명2
  FROM 테이블명1, 테이블명2
  (WHRER condition);
  ```

4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스는 데이터베이스 분야에서 테이블에 대한 동작의 속도를 높여주는 자료 구조이다. 키 값으로 행 데이터의 위치를 식별하는데 사용하는 기능이다.

- 인덱스 알고리즘

  - B-Tree 알고리즘
    - 가장 일반적으로 사용되는 인덱스 알고리즘이다.
    - 컬럼 값을 변형하지 않고, 원래 값을 기준으로 이용해서 인덱싱을 한다.
    - 루트노드, 브렌치 노드, 리프 노드로 나누어진다.
    - 리프 노드는 데이터가 저장된 레코드의 주소를 가지게 된다.
  - Hash Index 알고리즘
    - 컬럼 값으로 해시 값을 계산해서 인덱싱을 한다.
    - 값을 변형해서 인덱싱함으로 전방일치와 같이 값의 일부만 검색하고자 할 때 사용할 수 없다.
    - 주로 메모리 기반의 DB에서 많이 사용된다.

- 인덱스의 종류

  - 클러스터 인덱스(Primary Index): 특정 나열된 데이터들을 일정 기준으로 정렬해주는 인덱스다. 클러스터형 인덱스 생성 시에는 데이터 페이지 전체가 다시 정렬된다. 한개의 테이블에 한개씩만 만들 수 있다.
  - 보조 인덱스(Secondary Index): 논 클러스터 인덱스 (non-clustered index) 라고도 불린다. 개념적으로는 후보키에만 부여 할 수 있는 인덱스다. 보조 인덱스는 여러 개 생성할 수 있다.

- Index를 효과적으로 사용하려면?

  - 무조건 많이 설정하지 않는다. (한 테이블당 3~5개가 적당 목적에 따라 상이)
  - 조회시 자주 사용하는 컬럼에 인덱스를 걸어준다.
  - 고유한 값 위주로 설계한다.
  - 카디널리티가 높을 수록 좋다. (= 한 컬럼이 갖고 있는 중복의 정도가 낮을 수록 좋다.)
  - INDEX 키의 크기는 되도록 작게 설계한다.
  - PK, JOIN의 연결고리가 되는 컬럼에 인덱스를 걸어준다.
  - 단일 인덱스 여러 개 보다 다중 컬럼 INDEX 생성 고려해야 한다.
  - UPDATE가 빈번하지 않은 컬럼이어야 한다.
  - JOIN시 자주 사용하는 컬럼이어야 한다.
  - INDEX를 생성할 때 가장 효율적인 자료형은 정수형 자료이다.(가변적 데이터는 비효율적)

- 인덱스의 문법

  - 인덱스 생성

  ```sql
  -- 단일 인덱스
  CREATE INDEX 인덱스이름 ON 테이블이름 (컬럼명)

  -- 다중 컬럼 인덱스
  CREATE INDEX 인덱스이름 ON 테이블이름(컬럼명1, 컬럼명1, ...)
  ```

  - UNIQUE 인덱스 생성(중복 값을 허용하지 않는 인덱스)

  ```sql
  -- 단일 인덱스
  CREATE UNIQUE INDEX 인덱스 이름 ON 테이블이름(컬럼명1)

  -- 다중 컬럼 인덱스
  CREATE UNIQUE INDEX 인덱스 이름 ON 테이블이름(컬럼명1, 컬럼명2, ...)
  ```

  - 테이블을 생성할 때 인덱스를 지정

  ```sql
  CREATE TABLE person (
  -- 같이 지정
  id VARCHAR(5) primary key, -- 기본키 지정 (클러스터 인덱스)
  name VARCHAR(20) UNIQUE,   -- 인덱스 생성 (보조 인덱스) (중복 비허용)
  phone VARCHAR(20) NOT NULL,
  address VARCHAR(100) NOT NULL,

  INDEX idx_phone (phone asc)   -- 인덱스 생성 (보조 인덱스: 단일 컬럼, 오름차순으로 정렬)
  INDEX idx_name(name, address) -- 인덱스 생성 (보조 인덱스: 다중 컬럼 인덱스)
  );
  ```

  - 인덱스 조회

  ```sql
  SHOW INDEX FROM 테이블이름
  ```

  - 인덱스 추가

  ```sql
  ALTER TABLE 테이블이름
  ADD INDEX 인덱스이름(컬럼명1, 컬럼명2, ...);

  ALTER TABLE 테이블이름
  ADD UNIQUE INDEX 인덱스이름(컬럼명1, 컬럼명2, ...);

  ALTER TABLE 테이블이름
  ADD PRIMARY KEY INDEX 인덱스이름(컬럼명1, 컬럼명2, ...);

  ALTER TABLE 테이블이름
  ADD FULLTEXT INDEX 인덱스이름(컬럼명1, 컬럼명2, ...);
  ```

  - 인덱스 삭제

  ```sql
  DROP INDEX 인덱스이름 ON 테이블이름

  ALTER TABLE 테이블이름
  DROP INDEX 인덱스이름
  ```

  - 인덱스 정렬

  ```sql
  CREATE INDEX 인덱스이름
  ON 테이블이름 (컬럼명 DESC) -- 인덱스 지정한 컬럼명은 내림차순으로 정렬됨

  CREATE INDEX 인덱스이름
  ON 테이블이름 (컬럼명 ASC) -- 인덱스 지정한 컬럼명은 오름차순으로 정렬됨
  ```
