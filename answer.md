# 1.	관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

  ##	관계형 데이터베이스 (RDBMS)

  행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스로, SQL을 사용하여 조작한다.
  
  ### 장점
  * 데이터를 컬럼/로우 형태로 저장
  * 데이터의 분류, 정렬, 탐색 속도가 비교적 빠름
  * SQL이라는 구조화 된 질의를 통해 데이터를 다룰 수 있음
  * 작업의 완전성을 보장함
  * 데이터의 업데이트가 빠름
  ### 단점 
  * 반드시 스키마 규격에 맞춰서 데이터를 다뤄야 함
  *	데이터 처리에 대한 부하 발생시, 처리가 어려움

  ## 비관계형 데이터베이스 (NoSQL)

  Not only SQL. SQL을 사용하지 않는 데이터베이스

  Ex) MongoDB

  - JSON을 통한 데이터 접근 / Binary JSON(BSON) 형태로 데이터 저장
  - 키-값 데이터 모델에서 확장된 도큐먼트 기반의 데이터베이스

  Ex) Redis

  - 인메모리 데이터베이스 
  - 기본 데이터타입은 문자열(string), 최대 512MB까지 저장 가능

  ### 장점
  * 데이터간 관계를 정의하지 않음(테이블간의 join 불필요)
  * RDBMS보다 복잡도가 떨어짐-> 훨씬 대용량의 데이터 저장,관리 가능
  *	테이블 스키마가 정해져 있지 않아 데이터 저장이 비교적 자유로움
    => 다양한 도메인의 데이터베이스를 기반으로 분석하거나 로깅 등을 구현할 때 강점
  * 많은양의 데이터를 저장/처리할 수 있음


  ### 단점
  * 키값에 대한 입출력만 지원
  *	스키마가 정해져 있지 않아 데이터에 대한 규격화가 되어있지 않음
  *	데이터 업데이트가 비교적 느림


# 2.	트랜잭션(transaction)이란 무엇인가요?
데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업단위.

= 여러 개의 쿼리를 하나로 묶는 단위

## ACID (원자성,일관성,독립성,지속성)
### 원자성(Atomicity) = all or nothing
- 트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장한다.
  
  Ex) 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장한다

- 트랜잭션 단위로 여러 로직을 묶는 경우, 외부 API를 호출하는 것이 있으면 안 됨.

  => 롤백 수행시 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하며, 트랜잭션 전파를 신경써서 관리해야 함.

  #### 트랜잭션 전파
  트랜잭션을 수행할 때 커넥션 단위로 수행하기 때문에, 커넥션 객체를 넘겨서 실행해야 함
  커넥션 객체를 넘겨서 수행하지 않고 여러 트랜잭션 관련 메서드의 호출을 하나의 트랜잭션에 묶이도록 함
  #### 커밋과 롤백(Commit & Rollback)

  ##### 커밋: 여러 쿼리가 성공적으로 처리되었다고 확정하는 명령어
  트랜잭션 단위로 수행, 변경된 내용이 모두 영구적으로 저장
  커밋이 수행되었다 = 하나의 트랜잭션이 성공적으로 수행되었다

  ##### 롤백: 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌림(취소)
  데이터의 무결성이 보장됨
  데이터 변경 전에 변경 사항을 쉽게 확인 가능, 해당 작업 그룹화 가능

### 일관성(Consistency)
- 허용된 방식으로만 데이터를 변경한다.

- 데이터베이스에 기록된 모든 데이터는 여러가지 조건, 규칙에 따라 유효함을 가져야 한다.

### 격리성/독립성(Isolation)
- 트랜잭션 수행시 서로 끼어들 수 없다.

- 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 한다.

- 데이터베이스는 여러 사용자가 같은 데이터에 접근 가능해야 한다

  => 순차적으로 하면 쉽겠지만 성능이 떨어짐. 여러 개의 격리 수준으로 나누어 격리성 보장
           데이터 정합성과 성능은 반비례한다.
           
### 지속성 (Durability)
- 성공적으로 수행된 트랜잭션은 영원히 반영되어야 한다.
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구할 수 있는 회복 기능이 있어야 함.
- 데이터베이스는 이를 위해 체크섬,저널링,롤백 등의 기능을 제공함.

  ##### 체크섬
  중복 검사의 한 형태로, 오류 정정을 통해 송신된 자료의 무결성을 보호하는 단순한 방법.
  ##### 저널링
  파일 시스템 또는 데이터베이스 시스템에 변경 사항을 반영(commit) 하기 전에 로깅하는 것, 
  트랜잭션 등 변경 사항에 대한 로그를 남기는 것
  
## 격리 수준

### SERIALIZABLE (직렬화 가능)
    특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
    가장 높은 데이터 정합성을 갖지만, 성능은 가장 떨어진다.
    이 격리 수준에서는 단순한 셀렉트 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없다.
### REPEATABLE_READ (반복 가능한 읽기)
    특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준.
    SERIALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다. -> 팬텀 리드 발생   
    ( MySQL의 InnoDB 엔진의 기본 격리 수준.)
### READ_COMMITTED (커밋된 읽기)
    커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용한다.
    특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다.
    특정 트랜잭션에서 데이터가 변경되었으나, 아직 커밋되지 않은 상태라면 
    다른 트랜잭션에서는 해당 데이터에 접근했을 때 트랜잭션 시작 전 데이터를 읽어온다. 커밋이 된 이후에야 변경된 값을 읽어올 수 있다.
    가장 많이 사용되는 격리 수준이며, 오라클 등에서 기본값으로 설정되어 있다.
    팬텀 리드, 반복 가능하지 않은 조회 발생
### READ_UNCOMMITTED (커밋되지 않은 읽기)
    커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용하나.
    데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다.
    데이터를 어림잡아 집계하는 등의 연산에서 사용하면 좋다.
    팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 등의 문제가 발생한다.

### 격리 수준에 따라 발생하는 현상
  #### 팬텀 리드(phantom read)
  반복 불가능한 조회의 한 종류.
  한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회결과가 다른 경우
  (조회해온 결과의 행이 새로 생기거나 없어지는 경우)
  #### 반복 불가능한 조회(non-repeatable read)
  한 트랜잭션 내의 같은 행에 두번 이상 조회가 발생했는데, 그 값이 다른 경우
  
  -	반복 불가능한 조회는 행 값이 달라질 수도 있는데, 팬텀 리드는 다른 행이 선택될수도 있음
  #### 더티 리드(dirty read)
  특정 트랜잭션에 의해 데이터가 변경되었지만, 아직 커밋되지 않은 상황에서 다른 트랜잭션이 해당 변경사항을 조회할 수 있는 문제
  
  (이 문제는 트랜잭션 A가 데이터를 변경하고 커밋하지 않은 시점에 트랜잭션 B가 변경된 데이터를 읽어온 상황에서, 
  트랜잭션 A가 변경 내용을 커밋하지 않고 롤백한 상황에서 치명적이다. 
  트랜잭션 B는 무효가 된 값을 읽고 처리하므로 문제가 발생한다.)
     
     
# 3.	MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
하나의 테이블이 아닌 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것.
여러 테이블을 조인하는 작업이 많은 경우 관계형 데이터베이스를 사용(MongoDB 등은 lookup시 성능이 떨어짐)
### 내부 조인(inner join)
왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
### 왼쪽 조인(left outer join)
왼쪽 테이블의 모든 행이 결과 테이블에 표기됨. 
만약 오른쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 오른쪽 조인(right outer join)
오른쪽 테이블의 모든 행이 결과 테이블에 표기됨
만약 왼쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 합집합 조인(full outer join)
두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력됨


# 4.	MySQL에서 인덱스(index)란 무엇인가요?
테이블 안의 내가 찾고자 하는 데이터를 빠르게 찾을수 있게 함.
## 인덱스의 종류
### 클러스터형 인덱스 (primary key 옵션 또는 unique not null옵션)
테이블당 하나 설정 가능
### 세컨더리 인덱스 (create index …)
보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
### ? 인덱스를 매 필드마다 설정하면 어떻게 될까
* 인덱스는 두번 탐색을 강요한다: 인덱스 리스트 -> 컬렉션
* 읽기 관련 비용이 더 들게 된다.
* 테이블 수정시 인덱스도 수정되어야 한다.
따라서 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.
