# 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

## 데이터베이스란?

> 데이터베이스 : 물리적 데이터의 집합 혹은 저장소

- 데이터는 아직 가공되지 않은 날 것의 자료를 의미한다.
- 데이터를 조직화하고 가공하면 데이터에 의미가 생기고, 이러한 의미를 '정보'라고 한다.
- 데이터를 조직화하는 방식의 차이에 따라 RDBMS와 NoSQL로 나누어 진다.

<br>

## 관계형 데이터 베이스(RDBMS)

> 관계형 데이터 베이스는 고정된 행(Row, Instance)과 열(Column, Property)으로 구성된 테이블(Table)의 형태로 데이터를 저장한다.

- 각 열은 속성에 대한 정보를 저장하고, 행에는 각 열의 데이터 형식에 맞는 데이터가 저장된다.

- 관계형 데이트 베이스에서는 테이블의 구조와 데이터 타입을 사전에 정의한다.

<br>

### 관계형 데이터 베이스의 종류

- MySQL
- Oracle
- SQLite
- MariaDB
- PostgresSQL

<br>

> 관계형 데이터 베이스는 모두 SQL을 사용한다.

- 모든 관계형 데이터 베이스는 SQL을 사용하므로 RDBMS를 SQL로도 부른다.

<br>

## 비관계형 데이터베이스(NoSQL)

> 비관계형 데이터베이스는 SQL을 사용하는 RDBMS를 제외한(NoSQL) 다른 데이터베이스를 의미한다.

- NoSQL은 주로 데이터가 고정되어 있지 않은 데이터베이스를 가리킨다.
- 유연한 스키마를 제공하며, 대량의 데이터와 높은 사용자 부하에서도 손쉽게 확장 가능하다.
- 일반적인 표(Table) 형식이 아닌, 다른 방식으로 데이터를 저장한다.
- 관계형 데이터베이스는 정해진 스키마의 기준에 맞게 입력해야 하는 반면에, NoSQL에서는 데이터를 읽어올 때 스키마에 따라 데이터를 읽어온다.(Schema on Read)

<br>

### 스키마(Schema)란?

> 스키마란 개체(Entity), 속성(Attribute), 개체 사이의 관계(relation)에 대한 정의와 이들이 유지해야할 제약 조건을 기술한 메타데이터의 집합이다.

- DB 내에 어떤 구조로 데이터가 저장되는지 기술한 것이다.
- DB 사용자의 관점에 따라 외부 스키마, 개념 스키마, 내부 스키마로 나누어진다.
- RDBMS의 스키마는 변경이 가능하나, 데이터 베이스 전체를 수정하거나 오프라인으로 전환할 필요가 있다.
- NoSQL은 RDBMS보다 동적으로 스키마의 형태를 관리할 수 있다.
- 행을 추가할 때 즉시 새로운 열을 추가가 가능하고, 개별 속성에 대해서 모든 열에 대한 데이터를 반드시 입력하지 않아도 된다.

<br>

### 비관계형 데이터베이스(NoSQL) 유형

1. Key-Value 타입

> 속성을 Key(속성 이름)-Value(속성에 연결된 데이터) 쌍으로 나타내는 데이터를 배열의 형태로 저장한다.

- Redis, Dynamo

<br>

2. 문서형(Document) 데이터베이스

> 데이터를 테이블이 아닌 문서처럼 저장하는 데이터베이스이다.

- JSON과 유사항 형식의 데이터를 문서화하여 저장한다.
- 각각의 문서는 하나의 속성에 대한 데이터를 가지고 있고, 컬렉션이라고 하는 그룹으로 묶어서 관리한다.
- MongoDB

<br>

3. Wide-Column Store 데이터베이스

> 데이터 베이스의 열(column)에 대한 데이터를 집중적으로 관리하는 데이터베이스이다

- 각 열에는 key-value 형식으로 데이터가 저장되고, column families 라고 하는 열의 집합체 단위로 데이터를 처리할 수 있다.
- 하나의 행에 많은 열을 포함할 수 있다.
- 열을 유연하게 처리할 수 있으므로, 규모가 큰 데이터 분석에 주로 사용된다.
- Cassandra, HBase

<br>

4. 그래프(Graph) 데이터베이스

> 자료구조의 그래프와 비슷한 형식으로 데이터 간의 관계를 구성하는 데이터베이스이다.

- 각 노드에 속성별로 데이터를 저장한다.
- 각 노드와의 관계는 간선(edge)로 표현한다.
- Neo4J, InfiniteGraph

<br>

## RDBMS와 NoSQL의 장단점과 사용 케이스

- NoSQL은 SQL에 비해 확장성이나 속도면에서 더 뛰어나다.
- 그러나 고차원으로 구조화된 SQL 기반의 데이터 베이스가 더 좋은 성능을 보여주는 서비스도 있다.

<br>

1. 데이터베이스의 ACID 성질을 준수해야하는 경우는 SQL

- ACID는 Atomicity(원자성), Consistency(일관성), Isolation(격리성), Durability(지속성) 를 의미한다.
- 보다 안전하고 예외적인 상황을 줄여야할 경우 사용한다.(금융권)

<br>

2. 소프트웨어에 사용되는 데이터가 구조적이고 일관적인 경우에는 SQL

- 소프트웨어(프로젝트)의 규모가 많은 서버를 필요로 하지 않고 일관된 데이터를 사용하는 경우, 관계형 데이터베이스를 사용하는 경우가 많다.

<br>

3. 데이터의 구조가 거의 또는 전혀 없는 경우는 NoSQL

- NoSQL 데이터베이스는 저장할 수 있는 데이터의 유형에 제한이 없다.
- 비정형화 데이터가 필요한 경우(웹페이지, 비디오, 블로그 및 소셜 미디어 사이트에 대한 사용자 의견, 메모, 보고서, 문서, 녹취록 등등)에 사용한다.

<br>

4. 클라우드 컴퓨팅 및 저장공간을 최대한 활용해야하는 경우는 NoSQL

- 클라우드 기반으로 데이터베이스 저장소를 구축하면, 저렴한 비용의 솔루션을 제공받을 수 있다.
- 소프트웨어에 데이터베이스의 확장성이 중요하다면, 별다른 번거로움 없이 확장할 수 있는 NoSQL 데이터베이스를 사용하는 것이 좋다.

<br>

5. 빠르게 서비스를 구축하는 과정에서 데이터 구조를 자주 업데이트 해야하는 경우는 NoSQL

- NoSQL 데이터베이스의 경우 스키마를 미리 준비할 필요가 없기 때문에 빠르게 개발하는 과정에 매우 유리하다.
- 빠르게 프로토타입을 출시해야하는 경우에 해당한다.

<br>

# 2. 트랜잭션(transaction)이란 무엇인가요?

> 트랜잭션이란 데이터를 조작하기 위한 하나의 논리적인 작업 단위(일괄 처리)이다.

- 예를 들어, 온라인 퀴즈 이벤트를 진행하여 쿠폰을 발행해주는 이벤트가 있다고 하자
- 쿠폰은 선착순 100명에게만 지급된다.
- 이러한 경우, 다음 작업은 논리적으로 하나의 단위로 묶어야한다.

> - 이벤트 응모 이력을 저장한다.
> - 쿠폰을 발행한다.

- 사용자 -> 응모하기 -> 응모 이력 저장 -> 쿠폰 발행 -> 쿠폰 전달 -> 사용자

<br>

## 트랜잭션이 정상 종료되었을 때, Commit

> 트랜잭션이 정상적으로 수행이 되었을 때, 트랜잭션의 모든 작업 내용을 DB에 영구히 물리적으로 저장한다.

- T.S. : 사용자가 응모한 시점에 트랜잭션이 시작된다.
- T.E. : 사용자가 쿠폰을 전달 받으면 트랜잭션이 끝난다.

<br>

## 트랜잭션이 비정상적으로 시행되었을 때, Rollback

- 만일 쿠폰이 100개가 모두 소진되었는데, 사용자가 응모를 한다면?
- 비정상적인 트랜잭션이 발생하므로, 트랜잭션 이전 시점으로 Rollback을 해야한다.
- 즉, 항상 데이터베이스는 현재 시점만 나타내야 한다.

<br>

# 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

> 조인(join)이란 두 개 이상의 테이블에서 가져온 컬럼 관계를 이용해서 하나의 테이블인 것처럼 가져오는 작업이다.

- 예를 들어, 사원 정보 테이블과 부서 정보 테이블을 조인하여, 부서 번호(key)를 기준으로 부서별 사원 정보를 얻을 수 있다.
- 두 개 이상의 테이블에서 가져온 결과 중에 정확한 결과를 가져오기 위해서는 공통 부분을 이용해야 한다.

## Join의 역할

> 관계형 데이터베이스 내에서 Table을 효율적으로 분리할 수 있게 한다.

- 한 테이블에 너무 많은 정보가 담겨 있다면, 중복된 데이터가 많을 가능성이 크다.
- 즉 이러한 경우는 용량 낭비 및 관리가 어렵다는 단점이 있다.
- Join은 여러 테이블의 정보를 관계를 통해 하나의 테이블인 것처럼 보이게 할 수 있다.

<br>

## 특성에 따른 분류

<br>

### 등가 조인

1. Cross Join

   - 조건 없이 2개의 테이블을 하나로 조인하는 것이다.
   - 카테시안 곱이 발생한다.(대량의 테이블에서 카테시안 곱이 발생할 경우 SQL 명령문 처리 속도가 현저히 느려진다.)

2. Inner Join

   - 두 개의 테이블 간에 일치하는 것을 조인하여, 특정 조건에 맞는 정보들만 가져온다.

3. Self Join

   - 같은 테이블을 조인하는 것을 의미한다.

4. Outer Join

   - 조인 조건에 해당하지 않아 결과에 포함되지 않는 행까지 가져오는 조인이다.

   - Left Join, Right Join, Full Outer Join

<br>

### 비등가 조인

- 두개의 테이블 간에 조인하는 경우 '=' 조건이 아닌, '>', '<>' 등의 비등가 부호를 사용하는 것이다.

<br>

# 4. MySQL에서 인덱스(index)란 무엇인가요?

> 책 뒷편의 색인(Index)와 같이 빠르게 데이터의 위치를 찾을 수 있는 자료구조이다.

- 자주 사용되는 속성 값으로 만들어진 원본 테이블의 사본이라고 할 수 있다.

- MySQL의 Table Full Scan 검색 기능은, 데이터의 양이 클수록 탐색 시간이 길어진다.

- 이러한 문제점을 극복하기 위해 인덱스를 사용한다.

- 인덱스는 MYI(MySQL Index) 파일에 저장되며, 인덱스가 설정되지 않았다면 Table Full Scan이 일어나 성능이 저하되거나 치명적인 장애가 발생한다.

- 조회 속도(SELECT)는 빨라지나, UPDATE, INSERT, DELETE의 속도는 저하된다.

- 인덱스를 사용하면 전체를 읽을 필요가 없으므로 검색, 질의 성능이 향상된다.

- 단, 원본 테이블에 데이터의 수정, 삭제, 이 이루어지면 인덱스 또한 수정되어야 한다.

- 즉, 인덱스는 검색과 질의에 대해서만 사용되어야 한다.

## 테이블에 대한 인덱스 생성

<code>
    
    CREATE INDEX {인덱스이름}
    ON {테이블이름} (필드이름1, 필드이름2, ...)

</code>

## 해당 테이블의 인덱스 조회

<code>

    SHOW INDEX
    FROM {테이블이름}

</code>
