1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 관게형 데이터베이스는 모든 데이터를 표 형태의 테이블에 저장하고 데이터의 중복을 최소화해서 저장하도록 한다. 테이블은 관련 정보를 구하기 쉽고 제약 조건을 통해 무결성을 보장한다. 여러 개의 테이블을 만들고 관계를 정의함으로 복잡한 정보를 간결하게 저장할 수 있다. 관계형 데이터베이스는 유연성이 높아 비즈니스 로직 변화에 신속히 대처할 수 있다. 하지만 자원 소모가 높고 기능을 잘 활용하려면 많은 지식이 필요하다.

- 비관계형 데이터베이스는 관계나 join이라는 개념이 없고 분산 환경에서의 데이터 처리를 더욱 빠르게 하는데 사용할 수 있다. 비관계형 데이터베이스는 다른 구조의 데이터를 한 컬렉션(테이블)에 저장할 수 있다. 대용량 데이터를 처리하는데 효율적이며 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어나다. 하지만 사이즈가 큰 document(record)를 처리할 때는 비효율적이다.

2. 트랜잭션(transaction)이란 무엇인가요?

- DBMS는 데이터를 안전하게 지키고 극단적인 에러상황에 대처하기 위해 여러 가지 장치를 제공하는데 가장 기본적인 장치가 트랜잭션이다. 트랜잭션은 관련된 SQL문을 하나로 묶어 처리하는 작업 단위를 의미한다. 여러 명령을 하나로 묶어 처리하면 일관성과 영속성을 지킬 수 있다.

- ACID

  - 원자성, atomicity
    : 트랜잭션 내의 명령을 하나의 묶음으로 처리하여 모두 성공하거나 아니면 모두 실패한다.
  - 일관성, consistency
    : 트랜잭션으로 처리하는 데이터는 일관성을 유지한다. 어떤 상황에서도 데이터의 무결성을 지킨다.
  - 격리성, isolation
    : 데이터베이스는 원칙적으로 다중 사용자가 동시에 접속할 수 있어 여러 개의 트랜잭션이 동시에 실행되며 서로 방해하지 않는다. 따라서 트랜잭션 진행 중에는 중간 상태를 보거나 변경할 수 없다.
  - 영속성, durability
    : 트랜잭션을 성공적으로 수행하면 수정된 데이터를 시스템에 영구적으로 적용한다.

- 트랜잭션 처리 과정은 임시영역에 먼저 기록하고 트랜잭션의 커밋 여부에 따라 영구적으로 확정(commit)하거나 변경 전의 데이터로 되돌린다(rollback).

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인이란 두 개 이상의 테이블에서 조건에 맞는 데이터를 조회하는 방법이다.

- 단순조인, Cross join
  : 두 개 이상의 테이블을 조건없이 논리곱으로 곱한다.
- 내부조인, Inner join
  : 각 테이블의 필드값을 비교하여 조건에 맞는 레코드만 선택적으로 가져오는 명령
  : 조건에 맞지 않으면 레코드를 출력하지 않는다.
- 외부조인, Outer join
  : 주종 관계에 있는 테이블에서 주테이블의 모든 레코드를 보여주고 조건을 만족하는 부테이블의 필드를 같이 출력한다.
  : 조건에 맞지 않는 레코드도 같이 출력한다.
  - left outer join
    -> 주테이블 - 왼, 종속테이블 - 오
  - right outer join
    -> 주테이블 - 오, 종속테이블 - 왼
  - full outer join
    -> 주테이블 - 왼, 오

4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스는 데이터베이스 테이블의 검색 속도를 높이기 위한 방법으로 원하는 데이터가 저장되어 있는 주소를 가리키는 인덱스를 두어 빠른 데이터 검색이 가능해진다.

- 인덱스의 알고리즘
  - Full Table Scan
  - B-tree
  - B+tree -> 흔히 쓰이는 인덱스의 자료구조
  - 해시 알고리즘

인덱스를 사용하면 테이블을 조회하는 속도와 그에 따른 성능을 향상시켜 전체적으로 프로그램의 부하를 줄일 수 있다.

하지만 인덱스 기법 또한 단점을 가지고 있는데 인덱스 테이블을 따로 두기 위해서는 저장공간이 추가적으로 필요하다. 또한 기존 컬럼에 있던 데이터를 삭제, 갱신, 삽입하려면 인덱스 테이블에도 반영하기 위한 추가 작업이 필요해진다. 또한 인덱스가 가리키는 데이터를 삭제하더라도 인덱스를 삭제하지 않고 사용하지 않는다는 플래그만 세워두기 때문에 삽입, 삭제, 갱신이 빈번한 컬럼에 인덱스를 걸면 성능 저하를 야기할 수 있다.

인덱스 테이블을 따로 두는지 아닌지에 따라 클러스터링 인덱스와 논 클러스터링 인덱스로 나눌 수 있다.
클러스터링 인덱스는 실제 데이터 테이블 자체를 정렬하는 것으로 테이블당 1개만 존재할 수 있다. 따라서 primary 키를 설정하거나 unique + not null 제약을 두어 클러스터링 인덱스로 지정할 수 있다.
반면 논 클러스터링 인덱스는 별도의 인덱스 페이지를 두어 관리하는 방법이다. 따라서 테이블당 여러 개가 존재할 수 있으며 인덱스 페이지는 실제로 가리키는 데이터 페이지의 주소를 담고 있다. 원하는 칼럼에 unique 제약 조건을 걸어 인덱스로 지정할 수 있다.

인덱스는 카디널리티가 높은 컬럼에 적용하는 것이 효율적이다. 카디널리티란 그룹 내 요소의 개수로 카디널리티가 높다는 것은 중복도가 낮다는 것을 의미한다.
