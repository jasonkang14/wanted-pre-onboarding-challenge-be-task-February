1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

관계형 데이터베이스는 말그대로 **관계**에 중점을 둔 데이터베이스입니다.

먼저, 테이블이라는 구조를 통해 데이터를 저장하는데 그 테이블들에 있는 데이터들은 **관계**를 통해 여러 테이블에 분산되기도 합니다.

테이블 구조에는 **레코드**라는 테이블에 들어갈 수 있는 데이터와 그렇지 않은 데이터를 정의하는 필드 집합이 있습니다.

관계형 데이터베이스는 사용하기에 따라 코딩에서 사용되는 **클래스**와 1대1매핑해서 사용될 수 있습니다.

클래스에서 말하는 멤버변수들의 이름과 타입이 있는데,

```python
class ClonerRepository:
    name: str
    cloner_count: int
    today_cloner: int
```

이런 클래스가 있다면 `name`은 이름이고, `str`은 String이라는 문자열 타입입니다.

관계형 데이터베이스의 장점은 이렇게 이름과 타입을 1:1매핑하여 사용할 수 있다는 것입니다. 즉, 객체지향적인 방법으로 데이터베이스를 접근할 수 있다는 것입니다.

문제는, 여러 데이터베이스에 있는 필요한 데이터를 얻기위해서는 `join`을 사용할 수 있는데 제대로 사용하지 못하면 부하와 예상치 못한 결과를 받아올 수도 있다는 것입니다.

그리고 클래스에 필드가 추가되면은 데이터베이스의 필드에도 추가해야할 경우가 있는데,이 경우에는 다른 테이블에 어떤 영향을 미칠지 고민하는 과정이 필요해집니다.

그리고 `join`을 한 쿼리에서 많이 사용하다보면 결국 분리해주는 작업이나 추가적인 유지보수가 필요할 때가 있는데, 이 또한 쉬운 과정이 아닙니다. 

`NoSQL`은 관계형 데이터베이스의 단점을 어느정도 보완을 해주는데, 구조화되지 않은 이미지나 텍스트를 유연하게 다루게할 수 있기도하고 데이터베이스 스키마가 없어서 저장된 데이터를 언제든 조정이 가능하고, 새로운 **필드**도 엄격한 규칙없이 추가할 수 있습니다. 

다만, 데이터 변경이 이뤄지면 여러 문서를 수정해야할 수도 있습니다.

그래서 데이터 변경이 자주 일어나는 경우 상대적으로 부담이 덜한 `NoSQL`을 선택할 수도 있고 **읽기**연산이 많다면 조인연산이 없는 `NoSQL`을 선택하여 빠른 수행시간을 응답받을 수도 있게 합니다.

하지만 명확한 스키마가 중요하고 데이터구조가 자주 변경되지 않는다면 `SQL`형식의 관계형 데이터베이스를 고려할 수 있습니다.



2. 트랜잭션(transaction)이란 무엇인가요?

- 하나 이상의 작업이 원자 단위로, 즉 제일 최소 단위로 실행되는 일련의 작업들이 있을때 그 작업들은 모두 성공하거나 모두 함께 실패하여 데이터 무결성과 일관성을 보장하는 일련의 작업을 말합니다.

보통 ACID라는 특성을 따릅니다.

- Atomicity(원자성): 트랜잭션의 작업이 부분적으로 실행되거나 중단되지 않는 것을 의미합니다. 전부 다 실행되거나 전부 다 실행되지 않아야합니다.
- Consistency(일관성): 트랜잭션이 완료된 후, 트랜잭션 수행 전과 수행 후의 상태가 일관되어야 하는 것입니다. 만약에 의도치 않게 자료형이 바뀌거나 이름이 바뀌거나 하는 등의 작업은 일관성이 깨졌다고 볼 수 있습니다.
- Isolation(격리성): 트랜잭션 하나가 수행중일때 다른 트랙잰션이 이를 인터셉트해서 수행하지 않음을 보장해야합니다. 즉, 트랜잭션 서로 간섭할 수 없습니다.
- Durability(지속성): 트랙잰션을 수행하면 영원히 반영되어야 합니다. 의도치 않게 다시 수행전으로 돌아가거나 하지 않음을 보장해야합니다.


3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 데이터베이스 테이블간의 결합을 의미합니다. 즉, 조인을 하려면 두 개 이상의 테이블이 필요하며 한 테이블의 기본키와 참조 테이블의 외래키가 일치해야합니다.

조인의 종류에는 `Left Outer Join`, `Right Outer Join`, `Full Outer Join`, `Inner Join`이 있습니다.

### LEFT OUTER JOIN

```SQL
select *
from A a left outer join B b
on a.id = b.id
```

- 각 테이블의 중복값과 A테이블에 있는 값만 가져옵니다. (A-B + A교집합B)

### RIGHT OUTER JOIN

```SQL
select *
from A a right outer join B b
on a.id = b.id
```

- 각 테이블의 중복값과 B테이블에 있는 값만 가져옵니다. (B-A + A교집합B)

### FULL OUTER JOIN

```SQL
select *
from A a full outer join B b
on a.id = b.id
```

- 각 테이블에 들어있는 모든 값을 반환합니다. 매칭되는 데이터가 없으면 null을 가져옵니다. (A + b)

### INNER JOIN

```SQL
select *
from A a inner join B b
on a.id = b.id
```

- 두 개의 테이블에 중복되는 값을 가져옵니다. = 교집합


4. MySQL에서 인덱스(index)란 무엇인가요?

만약에 유저 테이블에 유저들의 이름을 담는다고 생각해보면, 'ㄱ'씨부터 'ㅎ'씨까지 있을겁니다.

만약 이름순으로 테이블이 정렬되어있고, 'ㄱ'씨가 99만명이 있고 'ㅎ'씨가 1만명이 있다고 하면 'ㅎ'씨를 찾기 위해서 'ㄱ'씨를 거쳐서 'ㅎ'씨를 찾게 될 겁니다.

즉, 99만명의 'ㄱ'를 조회하고 그 다음 조회했을때 'ㅎ'씨가 나오면 테이블은 이를 쿼리 결과 보내줄겁니다.

만약 'ㅎ'씨 조회가 'ㄱ'씨를 조회하는 경우보다 월등히 많다면 매 번 저 과정을 거치는건 성능상의 문제가 있을겁니다.

여기서 처음부터 'ㅎ'씨를 찾는게 좋은데, 이를 도와주는 것이 **인덱스**입니다.

이를 통해 검색 속도를 향상 시키지만 인덱스는 별도의 자료구조 형태로 구현되어 있어서 추가 공간이 필요하고 검색 외의 수정 등의 작업에 의해 성능이 약해질 수 있습니다.

인덱스 알고리즘 종류는 정말 많지만 보통 `B-Tree`를 사용합니다.

간단하게 말하자면 그 이유는 DB쿼리 조건으로 `<` `>`등의 연산을 수행할 수 있는데 이렇게 특정기준으로 작거나 큰 값을 찾기 위해서는 `B-Tree`가 적합하기 때문입니다.


