## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

### 1.1 관계형 데이터 베이스 (RDBMS)

관계형 데이터베이스는 데이터가 하나 이상의 열과 행의 테이블(또는 '관계')에 저장되어 서로 다른 데이터 구조가 어떻게 관련되어 있는지 쉽게 파악하고 이해할 수 있도록 사전 정의된 관계로 데이터를 구성(테이블, 행, 열의 정보를 구조화)하는 정보 모음입니다.
RDB에는 테이블을 조인하여 정보 간 관계 또는 링크를 설정할 수 있는 기능이 있어, 여러 데이터 포인트 간의 관계를 쉽게 이해하고 정보를 얻을 수 있습니다. 
관계는 이러한 테이블 간의 상호작용을 기반으로 설정되는 여러 테이블 간의 논리적 연결입니다.


#### 장점
- 데이터의 성능이 일반적으로 좋아 정렬, 탐색, 분류가 빠름
- 신뢰성이 높아 데이터의 무결성을 보장
- 정규화에 따른 갱신 비용을 최소화


#### 단점
- 기존에 작성된 스키마를 수정하기 어려움
- 데이터베이스의 부하를 분석하기 어려움
- 빅데이터를 처리하는데 매우 비효율적임.


ex) Mysql, Mssql, Oracle

<br>

### 1.2 비관계형 데이터 베이스 (NoSQL)

Not Only SQL(SQL 뿐만이 아닌. 이라는 뜻)의 줄임말로 기존의 관계형 데이터 베이스의 한계를 보안하기 위해 만들어졌다.
관계형 데이터베이스보다 더 융통성 있는 데이터 모델을 사용하며, 데이터의 저장 및 검색에 특화된 메커니즘을 제공합니다. 
NoSQL은 분산 환경에서의 데이터 처리를 더욱 빠르게 하기 위해 개발되었습니다.


- 거대한 Map으로서 key-value 형식을 지원함.
- 관계형 db와 달리 PK,FK JOIN등 관계를 정의하지 않음.
- 스키마에 대한 정의가 없다.

ex) MongoDB, CouchDB

<br>

#### 장점
 - 대용량 데이터 처리를 하는데 효율적임.
 - 읽기 작업보다 쓰기 작업이 더 빠르고 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 빠름.
 - 데이터 모델링이 유연함.
 - 뛰어난 확장성으로 검색에 유리함.
 - 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어남.
 - 복잡한 데이터 구조를 표현할 수 있음.

<br>

#### 단점
 - 쿼리 처리시 데이터를 파싱 후 연산을 해야해서 큰 크기의 document를 다룰 때는 성능이 저하됨.





<br><br>

## 2. 트랜잭션(transaction)이란 무엇인가요?
트랜잭션(Transaction 이하 트랜잭션)이란, 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위를 뜻합니다.

데이터베이스의 상태를 변화시키는 것에는 SELECT, INSERT, DELETE, UPDATE 방법이 있습니다.
주의할 점은 작업의 단위는 해당 질의어 한문장이 아니라 하나의 작업 단위를 트랜잭션이라고 합니다.
즉 트랜잭션은 사람이 설계한 논리적인 작업 단위입니다.

<br>

### 특징
트랜잭션의 특징은 아래와 같이 4가지로 구분됩니다.
- 원자성(Atomicity) : 트랜잭션이 데이터베이스에 모두 반영되던가, 아니면 전혀 반영되지 않아야 한다는 것을 의미합니다.
- 일관성(Consistency) : 트랜잭션의 작업처리 결과가 항상 일관성이 있어야 한다는 것입니다. 트랜잭션이 진행되는 동안에 데이터베이스가 변경되더라도 업데이트된 데이터베이스를 기반으로 트랜잭션이 진행되는 것이 아니라 처음에 참조한 데이터베이스를 기반으로 실행되어야합니다. 그래야만 사용자는 일관성 있는 데이터를 볼 수 있습니다.
- 독립성(Isolation) : 둘 이상의 트랜잭션이 동시에 실행되고 있는 경우 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없습니다. 트랜잭션이 완료되기 전까지는 다른 트랜잭션이 결과를 참조할 수 없습니다.
- 지속성(Durability) : 트랜잭션이 성공적으로 완료되었을 경우에 결과는 영구적으로 반영되어야합니다.

<br>

### 연산

- Commit 연산 : Commit 연산은 한개의 논리적 단위(트랜잭션)에 대한 작업이 성공적으로 끝났고 데이터베이스가 다시 일관된 상태에 있을 때, 이 트랜잭션이 행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산입니다.
- Rollback 연산 :  Rollback 연산은 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 이 트랜잭션의 일부가 정상적으로 처리되었더라도 트랜잭션의 원자성을 구현하기 위해 이 트랜잭션이 행한 모든 연산을 취소(Undo)하는 연산입니다.

<br>

### 상태
트랜잭션은 논리적으로 5가지의 상태에 있을 수 있습니다.

1. Active : 트랜잭션이 현재 실행 중인 상태
2. Failed : 트랜잭이 실행되다 오류가 발생해서 중단된 상태
3. Aborted : 트랜잭션이 비정상 종료되어 Rollback 이 수행된 상태
4. Partially Committed : 트랜잭션의 연산이 마지막까지 실행되고 Commit이 되기 직전 상태
5. Committed : 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태




<br><br>

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

### 3.1 조인(join)
join이란 한 데이터베이스 내의 여러 테이블을 관련있는 컬럼 기준으로 행을 합쳐주는 연산입니다.
관계형 데이터베이스에서는 중복 데이터를 피하기 위해서 데이터를 쪼개 여러 테이블로 나눠서 저장하게 됩니다.
join 연산자를 쓰면 이렇게 분리되어 저장된 데이터에서 원하는 결과를 도출할 수 있습니다.


<br>

### 3.2 join 방식

<img width="688" alt="image" src="https://user-images.githubusercontent.com/29567741/216354452-366cefcd-21c7-48f2-b259-f5c149bf104d.png">


#### Inner join


#### Equal join

#### Natural join


#### Cross join


#### Outer join


#### left outer join


#### right outer join


#### full outer join









<br><br>

## 4. MySQL에서 인덱스(index)란 무엇인가요?
인덱스는 데이터베이스 테이블에 대한 검색 성능의 속도를 높여주는 자료구조이다.
특정 컬럼에 인덱스를 생성(오른차순으로 정렬)하게 되면 해당 컬럼의 데이터들을 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다. 
이렇게 인덱스가 생성하였다면 앞으로 쿼리문에 "인덱스 생성 컬럼을 WHERE 조건으로 거는 등"의 작업을 하면 **옵티마이저**에서 판단하여 생성된 인덱스를 탈 수가 있다. 만약 인덱스를 타게 되면 아래의 그림과 같이 인덱스를 타게 되고 먼저 인덱스에 저장되어 있는 데이터의 물리적 주소로 가서 데이터를 가져오는 식으로 동작을 하여 검색 속도의 향상을 가져올 수 있다.


### 장점

#### 1. 조건 검색 WHERE 절의 효율성
테이블에 쌓인 데이터들은 내부적으로 순서가 없이 뒤죽박죽으로 저장이 된다.
뒤죽박죽 저장된 데이터들을 가진 테이블에서 WHERE 절을 사용할 떄는 처음부터 끝까지 다 읽어서 검색 조건과 맞는지 비교해야한다.
이것을 풀 테이블 스캔 (Full Table Scan) 혹은 풀 스캔 (Full Scan) 이라고 한다.
하지만 인덱스 테이블 스캔 (Index Table Scan) 수행시 해당 테이블들은 데이터들이 정렬되어 있기 때문에 WHERE 절에 맞는 데이터들을 빠르게 찾아낼 수 있다.


#### 2. ORDER BY 절의 효율성
인덱스를 사용하면 이미 데이터들이 정렬되어 있기 때문에 부하가 많이 걸리는 작업인 ORDER BY를 피할 수 있다.


#### 3. MIN, MAX의 효율적 처리 가능
테이블의 처음과 끝의 값을 각각 하나씩만 가져오면 되기때문에 Full Scan으로 테이블을 모두 뒤져서 작업하는 것보다 훨씬 빠르게 작업할 수 있다.

<br><br>

### 단점

#### 1. DML에 취약하다
INSERT, UPDATE, DELETE를 통해 데이터가 추가되거나 값이 바뀐다면 인덱스 테이블 내에 있는 값들을 다시 정렬을 해야 한다. 그리고 위에 사진처럼 인덱스 테이블, 원본 테이블 이렇게 두 군데의 데이터 수정 작업을 해줘야 한다는 단점도 발생한다. 그렇기 때문에 DML이 빈번한 테이블보다 검색을 위주로 하는 테이블에 인덱스를 생성하는 것이 좋다.


#### 2. 무조건 인덱스 스캔이 좋은 것은 아니다
인덱스는 테이블의 전체 데이터 중에서 10~15% 이하의 데이터를 처리하는 경우에만 효율적이고 그 이상의 데이터를 처리할 땐 인덱스를 사용하지 않는 것이 더 낫다. 

#### 3. 속도 향상을 위해 인덱스를 많이 만드는 것은 좋지 않다.
인덱스를 관리하기 위해서는 데이터베이스의 약 10%에 해당하는 저장공간이 추가로 필요하다. 무턱대고 인덱스를 만들어서는 결코 안 된다는 것이다. 즉, 속도 향상에 비해 단점들의 COST를 비교해서 인덱스를 만들지 말지를 정해야 한다.



<br><br><br><br>
