1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 관계형 데이터베이스는 데이터나 하나 이상의 행과 열로 이루어진 2차원 데이터베이스이다. 스키마와 PK, FK, Join 등을 정의한다.
- 관계형 데이터베이스의 장점
  -  데이터 종속성이 최소화된다. 데이터베이스 안의 데이터 구조가 변경되더라도 응용 프로그램에 간접적으로 영향을 미쳐 응용프로그램의 수정부담이 훨씬 적다
  -  데이터 중복성이 감소한다. 데이터베이스 안 데이터를 전체 데이터를 통합하여 데이터 구조를 생성하고 저장하기 때문에 데이터 중복이 감소한다.
  -  데이터 동시 공유가 가능하다. 사용자 수와 무관하게 사용자가 데이터베이스 내 데이터를 공유할 수 있다.
  -  데이터 일관성 유지/무결성 유지가 쉽다. 정규화로 인해 데이터의 중복이 최소화되고 간단한 제약조건을 통해 무결성을 유지할 수 있다.
- 관계형 데이터 베이스의 단점
  - 시스템 운영비용이 증가한다. 동시 사용자의 수에 비례하여 유지비용이 증가한다.
  - 시스템 관리 부담이 높아진다. 데이터베이스 관리자에 대한 전문성이 요구된다.
  - 시스템 취약성이 증가한다. 모든 데이터가 한 DBMS로 통합되기 때문에 장애가 빈번하게 발생하며 부적절한 데이터 노출 및 품질 손상의 위험도가 커진다.
  - 빅데이터를 처리하는데 대단히 비효율적이다,
 
- 비관계형 데이터베이스는 관계형 데이터베이스의 단점을 보완하기 위해 등장한 데이터베이스이다. 스키마, PK, FK, Join 대신 key-value를 정의한다. 
- 비관계형 데이터베이스의 장점
  - 대용량 데이터 처리에 효율적이다. key-value를 통해 데이터를 분산 저장한다.
  - 데이터 병목 현상이 적다. 데이터를 다수의 서버에 분산 저장하기 때문이다.
  - 관계형 데이터베이스에 비해 유연하게 데이터 모델을 변화시킬 수 있다.
  - 가변적인 구조의 데이터 저장이 가능하여 반정형, 비정형 데이터를 저장하는데 탁월하다,
- 비관계형 데이터베이스의 단점
  - 스키마가 정해져있지 않아 데이터에 대한 규격화가 되어있지 않다.
  - 데이터 중복으로 인해 수정작업이 원할하지 못하다.
  - join연산이 불가하기 때문에 데이터 간의 관계를 규정짓기 힘들다.

2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션이란 SQL 명령문들의 집합니다.
- 여러 단계의 처리를 하나로 간주하여 처리하는데 만약 특정 단계에서 오류가 발생할 경우 전체 명령이 취소되고 초기 상태로 되돌아 간다.
- 트랜잭션에는 다음과 같은 특징이 있다.
  - 원자성: 트랜잭션이 데이터베이스에 모두 반영되거나 혹은 일절 반영이 되지 않는 두 가지 중 하나의 상태가 되어야 한다. 
  - 일관성: 트랜젝션의 작업 처리 결과에 일관성이 있어야 된다는 뜻이다.
  - 독립성: 둘 이상의 트랜젝션이 동시에 병렬 처리될 경우 어느 하나의 트랜젝션이라도 다른 트랜젝션에 영향을 줄 수 없다,
  - 지속성: 트랜젝션이 성공적으로 반영되었을 경우 그 결과가 영구적이어 된다는 뜻이다.

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인이란 두 개 이상의 테이블을 서로 묶어서 하나의 결과를 만들어 내는 것을 말한다.
- 조인이 이루어지기 위해서는 기본키(Primary Key)와 외래키(Foreign Key)관계가 맺어있어야 하는데 이를 일대다 관계라고 한다.
- 조인에는 크게 4가지 종류가 있다.
  - 내부 조인(Inner Join) : 테이블 간 존재하는 공통적인 속성의 값이 같은 것을 결과로 내는 것인데 이 때 테이블 간에 지정한 값이 모두 존재해야 한다. 
  - 외부 조인(Outer Join) : 지정된 각 테이블 별로 일치하는 속성 뿐만 아니라 일치하지 않는 특성의 데이터도 같이 가져오는 조인이다.
    - 기준 테이블이 왼쪽 테이블이면 LEFT OUTER JOIN, 오른쪽 테이블이면 RIGHT OUTER JOIN이다.
    - 만약 기준 테이블에 없는 값이 있다면 NULL처리 된다.
  - 상호 조인(Cross Join) : 지정한 테이블을 조인할 때 가능한 모든 조합을 받아오는 조인이다. 
  - 자체 조인(Self Join) : 자기 자신을 조인하는 것으로 1개의 테이블만 있으면 된다.

4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스는 테이블의 동작속도, 즉 조회속도를 높여주는 자료구조이다.
- 조회속도(SELECT)는 빨라지지만 테이블의 정보를 갱신하는 작업(이를테면 UPDATE, INSERT, DELETE)의 속도는 느려진다. 
- 따라서 데이터를 조회할 때는 효과적이지만, 데이터 갱신이 자주 일어나는 DB인 경우 성능 저하를 불러일으킬 수 있다.
- 데이터를 저장하는 방식, 즉 알고리즘에 따라 크게 3가지로 분류된다.
  - B-Tree Index 알고리즘 : 칼럼의 값을 변형하지 않고 원래의 값을 이용하여 인덱싱하는 알고리즘
    - 최상위에 하나의 root 노드가 존재
    - 중간층에는 branch 노드가 존재
    - 최하위에는 leaf 노드가 존재
    - 장점 : 어떤 데이터를 조회하든지 조회과정의 길이와 비용이 같다.
    - 단점 : 데이터가 적은 테이블도 반드시 root ~ leaf를 거쳐야 하기 때문에 조회 과정 대비 속도가 느리다.
  - Hash Index 알고리즘 : 칼럼의 값을 해시 값으로 계산하여 인덱싱하는 알고리즘
    - 값을 변형해서 인덱싱 -> 동등비교 검색에는 최적화 but 범위 검색 or 정렬된 결과를 가져오는 용도로는 사용 불가
    - 장점 : 타 인덱스 대비 조회 속도가 매우 빠르다.
    - 단점 : 범위로 조회하는 작업은 속도가 느리다. 데이터 개수가 증가하면 더 큰 저장 공간을 요구한다.
  - Fractal-Tree Index 알고리즘 : B-Tree의 단점을 보완하기 위해 고안, 데이터 저장/삭제 시 비용 감소
