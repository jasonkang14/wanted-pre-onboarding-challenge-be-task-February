1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- __RDBMS는__ JOIN으로 서로 다른 테이블들을 연결하여 관계를 형성할 수 있는 데이터베이스입니다.    
즉, 컬럼으로(주로 PK, FK 또는 Index가 설정되어있는 컬럼) 서로 다른 테이블들을 연결할 수 있고, 연결된 관계에서 데이터를 핸들링(select, select insert, update, delete 등)할 수 있습니다.  
다만 __관계__ 라는 조건 때문에 Scale-up(수직 확장)은 쉽지만 Scale-out(수평 확장)은 다소 어렵습니다.


- __NoSQL은__ RDBMS와 다르게 관계가 정의되어있지 않습니다(=제약조건에서 상당히 자유로움).  
즉, __Scale-out에 유리__ 하고, 그렇기 때문에 방대한 트래픽을 통해 들어오는 데이터를 여러 개의 분산된 데이터베이스에 마구잡이로(물론 실무에서 정말 마구잡이로 저장하진 않지만...) 저장할 수 있습니다.  
다만 관계가 정의되어 있지 않아서 여러 테이블을 연결하여 데이터를 핸들링 할 수가 없습니다.  
상관 없는 이야기일 수도 있지만 NoSQL중 한 종류인 DynamoDB는 비용이... ㅠㅠ

2. 트랜잭션(transaction)이란 무엇인가요?

- __트랜잭션이란__ 데이터베이스의 환경(create, alter, drop) 또는 테이블 내의 데이터(insert, update, delete)에 __변화를 주는 작업의 단위__ 로 작업 성공 시 Commit을 하여 변경된 상태를 저장할 수 있고, 실패 시 자동으로 모든 변경 작업이 Rollback됩니다.  
단, Commit의 경우 auto로 설정되어있다면 한 트랜잭션이 종료된 후 자동으로 모든 변경사항이 저장됩니다(select @@autocommit; 으로 확인).

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 편의상 조인을 거는 대상을 __'주'__, 조인이 걸리는 대상을 __'부'__ 로 표현하겠습니다(master slave는 지양하기 때문에...).
- __조인이란__ 서로 다른 테이블을 __어떠한 목적을 가지고 연결__ 하는 것입니다.  
주로 Index 설정이 따로 필요 없는 PK 또는 FK로 조인관계를 맺고, 필요시 Index를 생성하여, 생성한 규약대로 조인관계를 맺습니다(조회 속도 향상).  
조인 종류는 다양하지만 실무에서는 inner join, left outer join을 압도적으로 많이 사용하고, 이 외에 full outer join 또는 right outer join을 간혹 사용하기도 합니다.  
__1) inner join__ 의 경우 연결한 두 테이블의 join 조건에 모두 부합한(true) 경우의 데이터만 추출합니다(=교집합).  
또한 자기 자신을 join 대상으로 설정할 수도 있는데, 저는 이를 ~~'지가 지를 조인건다.'~~ 라고 배웠습니다...  
__2) left outer join__ 의 경우 주 테이블의 row에 맞춰서 부 테이블의 데이터가 나오는 것으로, 부 테이블에 데이터가 없어도 __주 테이블의 데이터가 모두 조회__ 됩니다.  
이를테면 우리 회사 직원을 모두 조회하고 싶은데, 경비 사용 내역도 함께 조회하고 싶을 때 사용하기 적절합니다.  
(inner join으로 조회하면 경비를 사용한 내역이 있는 직원만 조회가 되겠죠?  
다만 left join으로 조회 시 경비를 사용하지 않은 직원들은 경비 사용 내역이 null로 조회되기 때문에 개발자가 적절한 조치를 해야할 수 있습니다.)  
__3) right outer join, full outer join__ 에서  
right outer join의 경우 left outer join의 반대의 경우라고 개념을 이해하고있지만 실무에서 사용해본 적이 없습니다...  
full outer join은 MySQL에서 공식적으로 지원하지 않습니다.

4. MySQL에서 인덱스(index)란 무엇인가요?

- __인덱스란__ 책에서 보는 Index와 같은 개념으로 목차 역할을 합니다.  
즉, 필요한 페이지를 찾을 때 목차를 보고 찾으면 빠르게 찾아갈 수 있듯, 데이터베이스도 만들어진 인덱스를 보고 필요한 데이터를 빠르게 가져올 수 있습니다(조회 뿐만 아니라 update, delete 속도에도 영향을 줍니다.).  
하나의 컬럼 또는 여러 개의 컬럼을 묶어서 index를 생성할 수 있으나, insert update delete의 수행 속도에 영향을 주기 때문에 되도록이면 데이터 변경이 자주 일어나지 않는 컬럼을 index로 만들어주는 것이 좋습니다.  
또한 index 생성 시 데이터베이스에 추가적인 공간이 필요하기 때문에 무분별한 index 생성은 오히려 데이터베이스 전체적인 성능을 저하시키거나 비용을 증가시키는 요인이 될 수 있습니다.
