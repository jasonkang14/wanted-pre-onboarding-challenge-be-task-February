# 1.	관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교
##	관계형 데이터베이스 (RDBMS)

---
  * 데이터는 정해진 스키마에 따라 테이블에 저장된다.
  * 데이터는 관계를 통해 여러 테이블에 분산된다.

    데이터는 테이블에 레코드로 저장된다.
    또한 테이블마다 명확하게 정의가 된 구조가 있는데, 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.

## 비관계형 데이터베이스 (NoSQL)

---
  * Not only SQL. SQL을 사용하지 않는 데이터베이스
  * 스키마도 없고, 관계도 없다. (관계가 없기 대문에 join이라는 개념이 없다.)
  * NoSQL에서는 레코드를 문서(document)라고 부른다.

### SQL과 차이점
1. SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능 했다.
   하지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가 가능하다.
2. 관계형 데이터베이스처럼 여러 테이블에 나누어 담지 않고, 관련 데이터를 동일한 컬렉션에 넣는다고 했는데 따라서 여러 테이블을 조인할 필요가 없다.
        

### key - value DB
  * Key-Value 방식으로 데이터를 저장
  * Key값은 모든 데이터 타입을 수용할 수 있고, 중복되지 않는 유니크한 값
  * 간단한 구조인 만큼 속도가 빠른 편이다.
  * 대표적으로 Redis, AWS DynamoDB, Riak 등이 있다.

### Document DB
  * Key-Document 형태로 저장
  * Document는 계층적인 데이터 타입(JSON, XML)으로 저장되는 장점이 있다.
  * JSON 타입을 사용하므로 HTTP 기반의 웹서버의 경우 데이터를 편리하게 주고받을 수 있다.
  * 대표적으로 MongoDB, Couch DB 등이 있다.

## 확장(Scaling)개념

---
   데이터베이스 서버의 확장성은 수직적 확장과 수평적 확장으로 나누어진다.
   * 수식적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것(CPU 업그레이드)
   * 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미(하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)
  
   RDBMS는 수직적 확장만 지원한다.

## SQL

---

### SQL의 장점
1. 명확하게 정의된 스키마 따라서 데이터 무결성을 보장한다.
2. 관계를 맺고있기 때문에 데이터를 중복없이 저장한다.

### SQL의 단점
1. 덜 유연하다. 데이터 스미카를 사전에 계획해야 한다.그로 인해 나중에 수정하기 힘들다.
2. 관계를 맺고있어 조인문이 많은 복잡한 쿼리가 만들어질 수 있다.
3. 수직적 확장만 가능하다.

## NoSQL

---
### NoSQL의 장점
1. 스키마가 없어서 유연하다. 따라서 새로운 필드 추가가 상대적으로 쉽다.
2. 데이터는 애플리케이션이 필요로 하는 형식으로 저장된다. 따라서 데이터 읽어오는 속도가 빠르다.
3. 수직 및 수정 확장이 가능하다.

### NoSQL의 단점
1. 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수정해야 한다.
   cf) SQL에서는 중복 데이터가 없기 때문에 한 번만 수정하면 된다.

## SQL vs NoSQL 언제 사용해야할까

---

### SQL 데이터베이스 사용이 더 좋을 때
* 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우 NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적
* 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### NoSQL 데이터베이스 사용이 더 좋을 때
* 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
* 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
* 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)


# 2. 트랜잭션(transaction)이란 무엇인가요?
## 트랜젝션이란?

---
> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
> 
> = 여러 개의 쿼리를 하나로 묶는 단위

* 상태를 변화시키는 것 -> SQL을 통해 DB에 접근
  * SELECT, INSERT, DELETE, 
* 작업 단위 -> 여러 개의 SQL 쿼리
> 예시) 사용자 A가 사용자 B에게 만원을 송금한다.
> 
> 이때, 작업 단위는 
> 1. 사용자 A가 계좌에서 만원을 차감한다. -> UPDATE문을 사용해서 사용자 A의 잔고 변경
> 2. 사용자 B의 계좌에 만원을 추가한다. -> UPDATE문을 사용해서 사용자 B의 잔고 변경

* 이 두 쿼리를 합쳐서 하나의 트랜젝션이라고 한다.
* Commit : 이 두 쿼리를 모두 성공해야 하나의 작업(트랜젝션)이 완료된다.
* Rollback : 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리를 취소하고 이전 상태로 되돌린다.
        

## ACID (원자성,일관성,독립성,지속성)

---
### 원자성(Atomicity) = all or nothing
* 트랜젝션이 DB에 모두 반영되거나 혹은 전혀 반영되지 않아야 한다.
* 롤백 수행시 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하며, 트랜잭션 전파를 신경써서 관리해야 함.
ex) 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장한다

  * #### commit
  하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산

  * #### rollback
  * 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우
  * transaction이 정상적으로 종료되지 않았을 때, (예) Transaction의 시작 상태) 로 roll back 할 수 있음.

### 일관성(Consistency)
* 트랜젝션의 작업 처리 결과는 항상 일관성 있어야 한다.

### 독립성(Isolation)
* 둘 이상의 트랜젝션이 동시에 병행 실행되고 있을 때, 어떤 트랜젝션도 다른 트랜젝션 연산에 끼어들 수 없다.
* 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 한다.
  => 순차적으로 하면 쉽겠지만 성능이 떨어짐. 여러 개의 격리 수준으로 나누어 격리성 보장
           데이터 정합성과 성능은 반비례한다.

### 지속성 (Durability)
- 트랜젝션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구할 수 있는 회복 기능이 있어야 함.
- 데이터베이스는 이를 위해 체크섬,저널링,롤백 등의 기능을 제공함

## 트렌젝션 격리 수준(Transaction Isolation Level)

---
### Isolation Level
트랜젝션에서 일관성 없는 데이터를 허용하는 수준

### Isolation Level의 필요성
데이터베이스는 트랜젝션이 독립적인 수행을 하도록 허용한다.
따라서 Locking을 통해 트랜젝션이 DB를 다루는 동안 다른 트랜젝션이 DB를 관여하지 못 하도록 막아야 한다.

하지만, 무조건 Locking으로 동시에 수행되는 수많은 트랜젝션들을 하나만 접근하도록 하여 순차적으로 실행하도록 하는 것은 데이터베이스의 성능을 떨어지게 한다.
그렇다고 해서 성능을 높이기 위해 Locking의 범위를 줄이면 잘못된 값이 처리될 수 있다.


따라서 적절한 Locking방법을 사용하는 것이 중요하다.

## Isolation Level 종류

---
### SERIALIZABLE (직렬화 가능)
* 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
* 가장 높은 데이터 정합성을 갖지만, 성능은 가장 떨어진다. 
  * 이 격리 수준에서는 단순한 셀렉트 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없다.
### Repeatable Read (반복 가능한 읽기)
<img width="497" alt="image" src="https://user-images.githubusercontent.com/88534959/216823524-e3ecf299-6122-49cc-a04a-75a4bd87956b.png">

* 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 없도록 막아준다. 

    하지만 새로운 로우를 추가하는 것은 막지 않는다. 따라서 SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다.

* 자신의 트랜잭션 번호(ID)보다 낮은 트랜젝션 번호에서 변경된(Commit)된 것만 읽고
* 자신의 트랜젝션 번호보다 높은 트랜젝션에서 변경된 것은 UNDO 영역에서 백업된 레코드를 읽는다.
* 하지만, UNDO 영역에 백업된 레코드가 많아지면 성능이 떨어질 수 있다.
### Read Committed(커밋된 읽기)
<img width="495" alt="image" src="https://user-images.githubusercontent.com/88534959/216823375-f144f853-fba6-4464-8421-f8b1198b6272.png">

* Commit이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용한다.

    특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다.
* Commit 되기 전에는 UNDO 영역에 백업된 레코드(트랜젝션 시작 전 데이터)에서 값을 가져온다.
* 이후 Commit이 완료된 이후에야 변경된 값을 읽어올 수 있다.
> 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함
### Read Uncommitted (커밋되지 않은 읽기)
<img width="510" alt="image" src="https://user-images.githubusercontent.com/88534959/216823060-3b352973-4ff7-4525-9192-a7ca02bfc773.png">

* Commit 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용
* 데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다.
> 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다


<img width="625" alt="image" src="https://user-images.githubusercontent.com/88534959/216826438-fa88c7c5-fdcc-4de6-88f9-17e192985c3f.png">

하지만 Dirty Read 문제점이 발생한다.
* Dirty Read : A가 한 데이터를 변경한 후 Rollback 했을 때 발생
# 3.	MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
서로 다른 테이블에서 데이터를 가져올 때 사용하는 것이 join이다.
여러 테이블을 조인하는 작업이 많은 경우 관계형 데이터베이스를 사용(MongoDB 등은 lookup시 성능이 떨어짐)
### 내부 조인(inner join)
왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
### 왼쪽 조인(left outer join)
왼쪽 테이블의 모든 행이 결과 테이블에 표기됨. 
만약 오른쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 오른쪽 조인(right outer join)
오른쪽 테이블의 모든 행이 결과 테이블에 표기됨
만약 왼쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 합집합 조인(full outer join)
두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력됨


# 4. MySQL에서 인덱스(index)란 무엇인가요?

추후 내용 추가
테이블 안의 내가 찾고자 하는 데이터를 빠르게 찾을수 있게 함.
## 인덱스의 종류
### 클러스터형 인덱스 (primary key 옵션 또는 unique not null옵션)
테이블당 하나 설정 가능
### 세컨더리 인덱스 (create index …)
보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
### 인덱스를 매 필드마다 설정하면 어떻게 될까
* 인덱스는 두번 탐색을 강요한다: 인덱스 리스트 -> 컬렉션
* 읽기 관련 비용이 더 들게 된다.
* 테이블 수정시 인덱스도 수정되어야 한다.
따라서 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.


### 챌린지를 신청한 이유

---
프로젝트를 진행하면서, 개발용으로 인메모리 DB는 h2, 운영용으로는 mysql, 캐싱을 위해서는 redis를 사용해왔습니다.
앞서, 이렇게 DB를 선택한 이유는 각 DB가 가장 익숙했기 때문입니다.
앞으로는 프로젝트를 진행하면서 프로젝트 특성에 적합한 DB를 선택하고자 합니다.

또햔, Index를 학교 수업시간에 배우기는 했지만, 언제 사용해야하는지 명확하게 알지 못했는데 
Index 개념 및 사용방법을 배워 Index를 통한 성능최적화를 해보고 싶숩니다.
