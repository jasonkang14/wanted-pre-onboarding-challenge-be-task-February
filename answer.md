## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

### RDBMS

#### 장점

- 명확한 스키마 덕에 일관성과, 무결성 보장.
- 데이터를 중복없이 한 번만 저장.

#### 단점

- 테이블간 관계를 맺고 있어, 복잡한 쿼리가 만들어질 수 있다.
- 수평 확장 어렵고, 수직 확장만 가능
	- Scale-up만 지원
	- 서버의 용량을 확장하는 Scale-up 시 다운타임 있을 수 있음.
- 정적인 스키마
	- 변경 어려움
	- 데이터가 유연하지 못함
	- 스키마에 적합하지 않은 레코드는 추가할 수 없다.
- 대량의 데이터 입력, 조회 시 성능 저하.


### NoSQL

#### 장점

- 유연한 스키마
	- 데이터 변경 유연함
	- 자유로운 데이터 구조를 가질 수 있음. 언제든 저장된 데이터를 조정하고 새로운 필드 추가 가능
- 데이터 분산이 용이
- 서버 확장 시 Scale-up, Scale-out 지원
	- 서버 증설
	- 기존의 서버를 유지하고 신규 서버를 증설하므로, 다운타임 거의 없음.

#### 단점

- 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 됨
- 스키마가 존재하지 않기 때문에 명확한 데이터 구조를 보장하지 않음.

## 2. 트랜잭션(transaction)이란 무엇인가요?

- __트랜잭션__ 는 데이터베이스의 상태를 변경시키기 위해 수행하는 작업의 단위이다.
	- 여러 작업을 묶어서 관리하는데, 하나라도 실패하면 그 작업이 속한 트랜잭션은 실패로 간주한다. 
	- 실패한 트랜잭션에 대해, 이미 실행한 작업을 저장하는 Commit이나 상태를 실행하기 전으로 돌려놓는 Rollback을 선택해서 처리할 수 있다.
- 하나의 DB에 여러 클라이언트가 동시 접근하거나, 프로그램이 프로세스 처리에 실패하는 등 데이터 부정합을 방지하려고 사용한다.
	- 안정성을 보장하기 위한 ACID 특성을 갖는다.

### ACID

#### Automicity (원자성)

- 모든 작업은 반영되거나 롤백 되어야 한다.
	- 하나의 트랜잭션에 a, b 작업이 묶여있다.
	- 이때 a, b 모두 성공하면 작업들이 반영되지만(Commit),
	- 만약 a는 성공하고, b는 실패했다면 모두 실패하게 만들어서 a의 상태를 돌려놓아야 한다.(Rollback)


#### Consistency (일관성)

- 데이터를 규칙에(스키마) 맞게 수정해야 한다.
	- 나이(int) 컬럼의 값을 문자열로 변경 => 불가능
	- 3글자까지만 작성 가능한 이름 컬럼의 값을 4글자로 변경 => 불가능

#### Isolation (독립성)

- 트랜잭션은 다른 트랜잭션으로부터 독립되어야 한다.
	- 포인트 점수가 1,000점이 되면 쿠폰이 발급되는 서비스가 있다.
	- 현재 포인트는 900이고 A 트랜잭션에서 200포인트를, B 트랜잭션에서 100포인트를 추가하려고한다.
	- 각각 A트랜잭션과 B트랜잭션에서 포인트를 추가하면 1,000포인트가 넘으므로 쿠폰 두 번 발급 => 독립성을 지키지 못한 동작이다.
		1. A트랜잭션에서 200포인트를 추가하므로 1,100포인트가 되고, 쿠폰 발급
		2. B트랜잭션에서 100포인트를 추가하므로 최종 포인트는 1,200포인트가 된다.
	
#### Durability (지속성)

- 한 번 반영된 작업의 결과는 영구적으로 지속된다.

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

### 조인

- 정규화 적용하면 이상현상이 있는 테이블을 분리하여 여러 테이블로 만든다. 분리된 테이블은 서로 관계를 갖는다.
- 정규화를 통해 중복, 반복되는 컬럼이 사라지면서 저장 공간을 확보할 수 있고, 확장성 또한 향상된다.
- 하지만 테이블을 분리한 탓에 한 번에 조회했던 데이터를 여러 번에 걸쳐 조회하는 불편함이 생긴다.
- 이때 분리된 테이블을 연결해서 데이터를 한 번에 검색할 수 있는 방법이 조인이다.
- 조인은 여러 테이블을 연결해서 데이터를 검색하는 방법이다.

### 조인의 종류

#### 동등 조인 (Equal join)

- 조인하려는 테이블들의 컬럼 값이 정확하게 일치하는 경우 사용
- = 연산자 사용

```sql
SELECT M.*, T.*
FROM MEMBER M, TEAM T
WHERE M.TEAM_ID = T.TEAM_ID;
```

#### 비동등 조인 (Non equal join)

- 조인하려는 테이블들의 컬럼 값이 정확하게 일치하지 않는 경우 사용
- >, >=, <, <=, <> 등의 연산자 사용

```sql
SELECT M.*, T.*
FROM MEMBER M, TEAM T
WHERE M.TEAM_ID <> T.TEAM_ID;
```

#### 자연 조인 (Natural join)

- 조인하려는 테이블 간의 동일한 이름을 갖는 모든 컬럼에 대해서 동등 조인 수행
- 조인에 이용되는 컬럼은 명시하지 않아도 자동 조인
- 이때 동일한 이름 뿐 아니라 동일한 타입 필수

```sql
SELECT M.*, T.*
FROM MEMBER M NATURAL JOIN TEAM T;
```

#### 교차 조인 (Cross join)

- 조인하려는 테이블 간의 M * N 건 조회
- 모든 데이터의 조합으로 조인을 생성

```sql
SELECT M.*, T.*
FROM MEMBER M CROSS JOIN TEAM T;
```

#### 내부 조인 (Inner join)

- join 조건에서 동일한 값이 있는 행만 조회

```sql
SELECT M.*, T.*
FROM MEMBER M INNER JOIN TEAM T
ON M.TEAM_ID = T.TEAM_ID;
```

#### 외부 조인 (Outer join)

- join 조건에서 동일한 값이 없는 행도 조회

__왼쪽 외부 조인 (Left outer join)__

- 조인 시 좌측에 먼저 입력 된 테이블의 데이터를 조회하고, 우측 테이블에서 join 대상 데이터를 조회
- 우측 테이블에서 join 조건을 만족하는 데이터가 없을 시, 우측 테이블의 데이터 값은 null로 조회

```sql
SELECT M.*, T.*
FROM MEMBER M LEFT OUTER JOIN TEAM T
ON M.TEAM_ID = T.TEAM_ID;
```

__오른쪽 외부 조인 (Right outer join)__

- 조인 시 우측에 입력 된 테이블의 데이터를 조회하고, 좌측 테이블에서 join 대상 데이터를 조회
- 좌측 테이블에서 join 조건을 만족하는 데이터가 없을 시, 좌측 테이블의 데이터 값은 null로 조회

```sql
SELECT M.*, T.*
FROM MEMBER M RIGHT OUTER JOIN TEAM T
ON M.TEAM_ID = T.TEAM_ID;
```

__완전 외부 조인 (Full outer join)__

- 조인 시 양 쪽 테이블의 모든 데이터를 조인하여 조회
- right outer join과 left outer join의 각 결과를 합집합한 것과 동일
- 중복되는 데이터는 삭제 (UNION 기능과 같음)

## 4. MySQL에서 인덱스(index)란 무엇인가요?

- 테이블의 검색 속도를 향상시키기 위한 자료구조, 책의 목차 역할
- 데이터베이스의 추가적인 공간을 사용
- B-tree, B+tree 형태로 저장

### 장단점

#### 장점
- 테이블 조회 속도 향상, 성능 향상
- 시스템 부하 감소

#### 단점
- 인덱스를 관리하기 위한 별도의 저장공간 필요
- 잘못 사용하는 경우 오히려 성능 저하
