1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교
- RDBMS의 장점
	- 구조(structure): RDBMS에는 잘 정의되고 구조화된 스키마가 있어 데이터를 쉽게 구성, 액세스 및 조작 가능.
	- 일관성(consistency): RDBMS는 트랜잭션 및 제약 조건을 통해 데이터 일관성과 무결성을 보장.
	- 쿼리(query): RDBMS는 강력하고 유연한 쿼리 언어인 SQL을 지원하므로 데이터를 쉽게 검색 가능.
	- 확장성(scalability): RDBMS는 수직(하드웨어 업그레이드) 및 수평(서버 추가)으로 쉽게 확장 가능.
- RDBMS의 단점
	- 강성(rigidity): RDBMS의 엄격한 구조로 인해 비정형 또는 반정형 데이터를 처리하기 어려움.
	- 성능(performance): RDBMS는 특히 많은 양의 데이터와 복잡한 쿼리를 처리할 때 성능 저하.

<br>

- NoSQL의 장점
	- 유연성(flexibility): NoSQL 데이터베이스에는 엄격한 스키마가 없으므로 구조화되지 않은 데이터와 반구조화된 데이터를 더 쉽게 처리 가능.
	- 확장성(scalability): NoSQL 데이터베이스는 대량의 데이터를 처리하도록 설계되었으며 클러스터에 더 많은 노드를 추가하여 쉽게 수평 확장 가능.
	- 성능(performance): NoSQL 데이터베이스는 고성능, 특히 읽기 집약적인 작업에 최적화.
- NoSQL의 단점
	- 구조(structure): NoSQL 데이터베이스에 정의된 구조가 없기 때문에 복잡한 쿼리를 수행하기가 더 어려움.
	- 일관성(consistency): NoSQL 데이터베이스는 RDBMS와 동일한 수준의 일관성 및 트랜잭션 보장을 제공하지 않을 수 있음.

<br>

2. 트랜잭션(transaction)이란 무엇인가요?

- 데이터베이스에 대해 수행되는 작업 단위. 오류나 예외가 발생할 경우 모두 완료되거나 모두 이전 상태로 롤백되어야 하는 하나 이상의 데이터베이스 작업 시퀀스.

- 데이터베이스에서 데이터의 일관성과 무결성을 보장하는 데 사용함. 예를 들어 사용자가 한 은행 계좌에서 다른 은행 계좌로 돈을 이체하려는 경우 트랜잭션을 사용하여 첫 번째 계좌에서 정확한 금액이 인출되고 두 번째 계좌로 입금되며 두 작업이 하나의 단위로 수행됨. 단일 원자 행동. 트랜잭션 중 첫 번째 계정의 인출 실패와 같은 오류가 발생하면 트랜잭션이 롤백되고 데이터가 이전 상태로 복원되어 데이터의 무결성이 유지됨.

- 작업이 여러 사용자에 의해 동시에 수행되는 경우에도 여러 작업을 일관된 단일 작업으로 수행할 수 있도록 하는 메커니즘을 제공. 트랜잭션을 사용하면 여러 데이터베이스 작업을 단일 작업 단위로 그룹화하고 단위의 모든 작업이 완료되거나 완료되지 않도록 하는 것이 가능.

<br>

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- MySQL에서 조인 작업은 두 개 이상의 테이블 사이의 관련 열을 기반으로 행을 결합하는 데 사용. 조인의 목적은 데이터가 단일 테이블에 저장된 것처럼 여러 테이블에서 데이터를 검색하는 것.

- 조인은 관련 열의 값을 기반으로 한 테이블의 행을 다른 테이블의 행과 일치시켜 수행됨.
	- INNER JOIN은 두 테이블에서 일치하는 값이 있는 행만 반환.
	- LEFT JOIN은 왼쪽 테이블의 모든 행과 오른쪽 테이블의 일치하는 행을 반환하고 누락된 값을 NULL 값으로 설정.
	- RIGHT JOIN은 오른쪽 테이블의 모든 행과 왼쪽 테이블의 일치하는 행을 반환.
	- FULL OUTER JOIN은 두 테이블의 모든 행을 반환하고 누락된 값을 NULL 값으로 설정.

<br>

4. MySQL에서 인덱스(index)란 무엇인가요?

- MySQL에서 인덱스는 데이터베이스 테이블에서 데이터 검색 작업의 속도를 향상시키는 데이터 구조. 전체 테이블을 스캔하지 않고 하나 이상의 열에 있는 값을 기반으로 테이블에서 행을 조회하는 방법을 제공.

- 데이터 저장소: 인덱스는 테이블의 해당 행에 대한 인덱스 열 값의 매핑을 포함하는 일반적으로 B-트리 형식의 별도 데이터 구조로 저장. B-트리의 각 노드에는 키-포인터 쌍 세트로 구성. 여기서 키는 인덱싱된 열의 값이고 포인터는 테이블에서 해당 행의 위치를 가리킴.

- 데이터 검색: 인덱스 컬럼의 값을 기반으로 데이터를 검색하는 쿼리가 실행되면 데이터베이스는 인덱스를 사용하여 원하는 행을 찾는다. B-트리의 루트 노드에서 시작하여 이진 검색을 수행하여 검색 키를 각 노드의 키와 비교하여 방문할 다음 노드를 결정함. 이 프로세스는 원하는 행을 찾거나 인덱스에 검색 키가 없다고 판단될 때까지 계속하다가 원하는 행을 찾으면 데이터베이스는 테이블에서 해당 데이터를 검색하여 쿼리에 반환. 쿼리가 많은 수의 행을 반환하는 경우 데이터베이스는 필요한 메모리 양을 최소화하고 성능을 향상시키기 위해 더 작은 청크로 데이터를 검색할 수 있음.

- 인덱스 업데이트: 테이블에서 데이터가 추가, 수정 또는 삭제되면 인덱스의 해당 항목이 변경 사항을 반영하도록 업데이트 해서 인덱스가 정확하고 최신 상태로 유지되고 인덱스를 사용하는 향후 쿼리가 올바른 결과를 반환.
