## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교
### 관계형 데이터베이스(RDBMS)
- 관게형 데이터베이스는 데이터를 행과 열로 이루어진 2차원 테이블에 저장되어 데이터의 종속성을 테이블 간의 관계로 표현
- 테이블 간의 관계를 직관적으로 파악하기 좋음
- 구조화된 데이터의 모음 -> 구조화된 쿼리 언어(SQL) 사용
- 장점
  - 데이터의 분류, 정렬, 탐색 속도가 빠름
  - 데이터 간의 물리적 연결 없이 데이터 간의 연결이 필요할 때만 내용에 의한 참조를 함으로써 독립성, 유연성을 가짐
  - 데이터의 중복이 없어 일관성을 가지며 무결성 보장
  - 스키마에 맞게 데이터를 입력하므로 구조가 명확   
- 단점
  - 복잡한 Join문으로 인한 성능 저하가 발생 가능
  - 데이터 스키마가 반드시 정의되어야 함
  - 빅데이터를 스키마에 넣을 때 많은 시간 소요됨
### 비관계형 데이터베이스(NoSQL)
- 관계형 데이터베이스를 뺀 나머지 유형을 총칭 (non SQL or not only SQL)
- 레코드를 문서(document)라고 정의
  - Json과 비슷한 형태(key-value 형식)
  - 테이블로 나누는 것이 아니라 관련 데이터를 동일한 컬렉션에 넣음 -> 조인이 필요없는 구조
- 분산 환경에서 대용량의 비정형화된 데이터를 빠르게 처리
- 읽기 작업을 더 많이 할 때 유리
- 장점
  - 스키마 선언 없이 필드의 추가 및 삭제가 자유로운 Schema-less 구조
    - 다른 구조의 데이터를 같은 컬렉션에 추가 가능  
  - 스케일 아웃에 의한 서버 확장이 용이
    - 수직적 확장 : 데이터베이스 서버 성능 향상
    - 수평적 확장 : 서버 자체를 늘림 -> 데이터베이스가 분산됨 (NoSQL에서만 가능)
  - 대용량 데이터를 처리하는 성능 뛰어남
  - 여러 대의 백업 서버 구성이 가능하여 장애 발생 시에도 무중단 서비스가 가능 
- 단점
  - key값에 대한 입출력만 지원
  - 스키마가 정해져 있지 않아, 데이터에 대한 규격화 X
  - 데이터가 여러 컬렉션에 중복되어 있어 Update 하는 경우 모든 컬렉션에서 수행하므로 속도 느림
  - 데이터 중복으로 인한 수정 작업의 번거로움 
- 유형
  - key-value 타입
    - 속성을 Key-Value의 쌍으로 나타내는 데이터를 배열의 형태로 저장
    - Redis, Dynamo
  - 문서형 데이터베이스
    - 데이터를 테이블이 아닌 문서처럼 저장하는 데이터베이스
    - JSON과 유사한 형식의 데이터를 문서화하여 저장
    - 각각의 문서는 하나의 속성에 대한 데이터를 가지고 있고, 컬렉션이라고 하는 그룹으로 묶어서 관리
    - MongoDB
  - wide-column store 데이터베이스
    - 데이터베이스의 열(column)에 대한 데이터를 집중적으로 관리
    - 각 열에는 key-value 형식으로 데이터가 저장, 컬럼 패밀리(column families)라고 하는 열의 집합체 단위로 데이터를 처리
    - 하나의 행에 많은 열을 포함할 수 있어서 유연성 높임
      - 규모가 큰 데이터 분석에 주로 사용
    - Cassandra, HBase 
    
  - 그래프 데이터베이스
    - 자료구조의 그래프와 비슷한 형식으로 데이터 간의 관계를 구성
    - 노드에 속성별로 데이터 저장
    - 각 노드 간 관계는 선으로 표현
    - Neo4J, InfiniteGraph

## 2. 트랜잭션(transaction)이란 무엇인가요?
### 트랜잭션
- 데이터베이스의 상태를 변화시키기 해서 수행하는 작업의 단위(CRUD)
- 하나의 트랜잭션은 Commit or Rollback됨
- 특징
  - 원자성 (Atomicity)
    - 트랜잭션이 데이터베이스에 모두 반영 or 전혀 반영되지 않아야 함
    - 트랜잭션 내의 모든 명령은 반드시 완벽히 수행되어야 하며, 어느하나라도 오류가 발생하면 트랜잭션 전부가 취소
  - 일관성 (Consistency)
    - 트랜잭션의 작업 처리 결과가 항상 일관성 있어야 함 
    - 시스템이 가지고 있는 고정요소는 트랜잭션 수행 전과 트랜잭션 수행 완료 후의 상태가 같아야 함
  - 독립성 (Isolation)
    - 둘 이상의 트랜잭션 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없음
    - 수행중인 트랜잭션은 완전히 완료될 때까지 다른 트랜잭션에서 수행 결과를 참조할 수 없음
  - 지속성 (Durability)
    - 트랜잭션이 성공적으로 완료됐을 경우, 결과는 영구적으로 반영
- 연산
  - Commit
    - 한 개의 논리적 단위에 대한 작업이 성공적으로 끝났고, 데이터베이스가 다시 일관된 상태에 있을 때, 해당 트랜잭션의 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려주는 연산
  - Rollback
    - 하나의 트랜잭션 처리가 비정상적으로 종료되어 데이터베이스의 일관성을 깨뜨렸을 때, 트랜잭션의 일부가 정상적으로 처리되었더라도 원자성 구현을 위해 모든 연산을 취소
    - 해당 트랜잭셕 재시작 or 폐기   
- 상태
  - 활동
    - 트랜잭션이 실행 중 
  - 실패
    - 트랜잭션 실행에 오류 발생하여 중단 
  - 철회
    - 트랜잭션 비정상적으로 종료되어 Rollback 연산을 수행한 상태 
  - 부분 완료
    - 트랜잭션의 마지막 연산까지 실행했고 Commit 연산 실행되기 직전의 상태  
  - 완료
    - 트랜잭션 성공적 종료 후 Commit 연산 실행한 후의 상태 
## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
### 조인
- 두 개 이상의 테이블을 묶어서 하나의 결과 집합으로 나타내는 것
- 종류
  - Left/Right outer join
    - 합칠 때 기준이 되는 테이블의 데이터는 전부 출력
    - 한쪽 테이블에만 내용 있어도 리턴됨 ->일치하지 않는 데이터는 NULL로 리턴
  - inner join
    - 조인하는 테이블들의 조건이 일치하는 결과만 출력(교집합)
  - cross join
    - 한쪽 테이블의 행 하나당 다른 쪽 테이블의 모든 행을 하나씩 모든 행들을 각각 조인
    - 행의 개수는 A 테이블 행의 개수 X B 테이블 행의 개수
    - 카티션 곱(Catesian Product)
  - self join
    - 자기 자신에게 조인
 
## 4. MySQL에서 인덱스(index)란 무엇인가요?
### 인덱스(Index)
- 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료구조
- 테이블 내의 1개의 컬럼 혹은 여러 개의 컬럼을 이용해서 생성
- 트리 구조를 활용해 데이터를 저장 (B-tree, B+tree)
- 장점
  - 테이블 검색 속도, 성능 향상 + 시스템 부하 줄일 수 있음
  - 데이터의 range 넓고, 중복 적을수록 효율적
  - 규모가 크고 읽기 작업이 더 많은 테이블에 효과적
- 단점
  - 컬럼을 복사해서 정렬하기 때문에 DB 용량을 더 차지
  - 인덱스를 항상 정렬된 상태로 유지하기 위한 추가 작업이 필요
    - 삽입, 삭제, 수정 작업이 일어나면 인덱스에도 반영 필요
  - 데이터의 수정이 잦은 경우 오히려 성능 저하 될 수 있음 
- Clustered Index
  - 테이블의 데이터를 지정된 컬럼에 대해 물리적으로 재배열하기 때문에 한 테이블에 한 컬럼만 가능 (ex. PK)
  - 데이터의 삽입 순서에 상관없이 Index로 생성되어 있는 컬럼의 기준으로 정렬되어 삽입
  - Index Page를 키값과 데이터 페이지 번호로 구성하고 검색하는 데이터의 키 값으로 페이지 번호를 검색하여 데이터를 찾음
  - root page + leaf page로 구성되는데 leaf page는 데이터 그 자체
    - Index Page를 따로 만들지 않고 테이블에 속해 있음
  - NonClustered Index보다 검색은 빠르고 입력, 수정, 삭제는 느림  
- NonClustered Index
  - 테이블에 저장된 물리적인 순서에 따라 데이터를 정렬하지 않음
  - Index Page만 정렬
  - Index는 테이블 데이터와 함께 저장하지 않고 별도의 장소에 보관됨
  - 데이터의 행에 독립적이고 인덱스 키 값과 데이터 행을 가리키는 `포인터` 존재
    - 인덱스 자체의 leaf page는 데이터가 아니라 포인터
    - 클러스터 인덱스보다 검색 속도는 느리고 입력, 수정, 삭제는 더 빠름   
