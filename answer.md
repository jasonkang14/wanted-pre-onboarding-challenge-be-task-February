1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 관계형 데이터베이스란?
    - 관게형 데이터베이스는 테이블, 행, 열을 가진 DB에 A데이터와 B데이터가 있다고 가정을 하면, <br>A데이터에 B데이터의 위치를 저장하는 방식으로, 행과 열로 구성된 테이블과의 관계를 나타낼 때 사용한다.

    - 예시
        - Mysql
        - Oracle
        - Mssql

    - 특징
        - 트랜잭션(전부 아니면 무): 전체 트랜잭션이 하나의 단위로 기록. 실패 시 전체 롤백
        - 정규화: DB설계 시 중복을 최소화해서 구조화하는 프로세스

    - 장점
        - 데이터의 성능이 일반적으로 좋아 정렬, 탐색, 분류가 빠름
        - 신뢰성이 높아 데이터의 무결성을 보장
        - 정규화에 따른 갱신 비용을 최소화

    - 단점
        - 기존에 작성된 스키마를 수정하기 어려움
        - 데이터베이스의 부하를 분석하기 어려움
        - 빅데이터를 처리하는데 매우 비효율적임


- 비관계형 데이터베이스란?
    - NoSQL이라고도 부르며, Not Only SQL(SQL 뿐만이 아닌. 이라는 뜻)의 줄임말이다. 즉, SQL뿐만 아니라 다른 여러 장점을 가지고 있다는 의미이다.
    - 기존의 관계형 데이터베이스의 한계를 뛰어넘기 위해 만들어진 새로운 형태의 데이터베이스라서, 관계형 데이터베이스보다 더 융통성 있는 데이터 모델을 사용하며, 데이터의 저장 및 검색에 특화된 메커니즘을 제공한다.
    - NoSQL은 분산 환경에서의 데이터 처리를 더욱 빠르게 하기 위해 개발되었다.

    - 예시
        - MongoDB
        - CouchDB

    - 특징
        - 거대한 Map으로서 key-value 형식을 지원함.
        - 관계형 db와 달리 PK,FK JOIN등 관계를 정의하지 않음.
        - 스키마에 대한 정의가 없다.

    - 장점
        - 대용량 데이터 처리를 하는데 효율적임.
        - 읽기 작업보다 쓰기 작업이 더 빠르고 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 빠름.
        - 데이터 모델링이 유연함.
        - 뛰어난 확장성으로 검색에 유리함.
        - 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어남.
        - 복잡한 데이터 구조를 표현할 수 있음.

    - 단점
        - 쿼리 처리시 데이터를 파싱 후 연산을 해야해서 큰 크기의 document를 다룰 때는 성능이 저하됨.



2. 트랜잭션(transaction)이란 무엇인가요?<br>
- 트랜잭션은 작업의 완전성을 보장한다.<br>즉, 논리적인 작업 셋을 모두 완벽하게 처리하거나 또는 처리하지 못할 경우에는 원상태로 복구해서 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능이다.
- 사용자의 입장에서는 작업의 논리적 단위로 이해할 수 있고, 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

- 트랜젝션의 특성 (ACID)
    - 원자성 (Atomicity)
    만약 트랜젝션 중간에 어떠한 문제가 발생한다면 트랜젝션에 해당하는 어떠한 작업 내용도 수행되어서는 안되며 아무런 문제가 발생하지 않았을 경우에만 모든 작업이 수행되어야 한다.
    - 일관성 (Consistency)
    트랜젝션이 완료된 다음의 상태에서도 트랜젝션이 일어나기 전의 상황과 동일하게 데이터의 일관성을 보장해야 한다.
    - 고립성 (Isolation)
    각각의 트랜젝션은 서로 간섭없이 독립적으로 수행되어야 한다.
    - 지속성 (Durability)
    트랜젝션이 정상적으로 종료된 다음에는 영구적으로 데이터베이스에 작업의 결과가 저장되어야 한다.





3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인이란 두 테이블을 결합하는 연산이다.
각, 테이블은 각자에 맞는 데이터를 저장하고 있는데, 서로 다른 테이블에서 데이터를 가져오려면 JOIN 연산을 해야 한다.<br>
<img width="671" alt="스크린샷 2023-01-31 오후 11 59 39" src="https://user-images.githubusercontent.com/59405576/215795764-f603c001-da36-434a-87a8-ca7778fad063.png">

- 다양한 JOIN의 방식을 쉽게 이해하기 위해 아래 예시로 설명한다.<br>
<img width="607" alt="스크린샷 2023-01-31 오후 11 39 08" src="https://user-images.githubusercontent.com/59405576/215790576-5c89c4ea-5bb3-47bf-bd2a-4b569e98ded0.png">

- LEFT JOIN
    - 쿼리
    ```sql
    SELECT * FROM A 
    LEFT JOIN B 
    ON A.id = B.id
    ```
    - A 값의 전체와, A의 KEY 값과 B의 KEY 값이 같은 결과를 리턴
    - <img width="531" alt="스크린샷 2023-01-31 오후 11 39 25" src="https://user-images.githubusercontent.com/59405576/215790644-4fb496e1-ce8c-48d5-8b8f-821b0987e4c9.png">

- LEFT JOIN (IS NULL)
    - 쿼리
    ```sql
    SELECT * FROM A 
    LEFT JOIN B 
    ON A.id = B.id
    WHERE B.id IS NULL
    ```
    - LEFT JOIN 결과에서 B 테이블과 연결이 없는 A의 결과를 리턴
    - <img width="560" alt="스크린샷 2023-01-31 오후 11 46 49" src="https://user-images.githubusercontent.com/59405576/215792513-bf1e7335-5480-4b03-a239-d62b2b7dd1ac.png">

- INNER JOIN
    - 쿼리
    ```sql
    SELECT * FROM A 
    INNER JOIN B 
    ON A.id = B.id
    ```
    - <img width="602" alt="스크린샷 2023-01-31 오후 11 47 18" src="https://user-images.githubusercontent.com/59405576/215792635-dc83f301-df99-4b81-9774-95c93e1d7112.png">

- RIGHT JOIN
    - 쿼리
    ```sql
    SELECT * FROM A 
    RIGHT JOIN B 
    ON A.id = B.id
    ```
    - B 값의 전체와, A의 KEY 값과 B의 KEY 값이 같은 결과를 리턴
    - <img width="571" alt="스크린샷 2023-01-31 오후 11 55 03" src="https://user-images.githubusercontent.com/59405576/215794586-7e0668ab-4f78-409f-a44c-6337a6c57105.png">

- FULL OUTER JOIN
    - 쿼리
    ```sql
    SELECT * FROM A 
    FULL OUTER JOIN B 
    ON A.id = B.id
    ```
    - <img width="599" alt="스크린샷 2023-01-31 오후 11 47 55" src="https://user-images.githubusercontent.com/59405576/215792795-2445a157-4569-4203-bc3a-a5362134d139.png">


4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스(index)는 테이블에서 원하는 데이터를 쉽고 빠르게 찾기 위해 사용한다.<br>
이러한 인덱스는 자주 사용되는 필드 값으로 만들어진 원본 테이블의 사본이라고 생각할 수 있다.
- MySQL은 데이터를 검색할 때 첫 번째 필드부터 차례대로 테이블 전체를 검색한다.
따라서 테이블이 크면 클수록 데이터를 탐색하는 시간도 많이 늘어나게 된다.
- 하지만 인덱스를 사용하면 테이블 전체를 읽지 않아도 되므로, 검색과 질의에 대한 처리가 빠르게 이루어진다.
- 이러한 인덱스는 사용자가 직접 접근할 수는 없으며, 검색과 질의에 대한 처리에서만 사용된다.
- 이렇게 인덱스가 설정된 필드 값을 포함한 데이터의 삽입, 삭제, 수정 작업이 원본 테이블에서 이루어질 경우, 인덱스도 함께 수정되어야 한다.<br>따라서 인덱스가 설정된 테이블의 처리 속도가 느려질 수 있다.
- 그러므로 인덱스는 수정보다는 검색이 자주 사용되는 테이블에서 사용하는 것이 더 좋다.
