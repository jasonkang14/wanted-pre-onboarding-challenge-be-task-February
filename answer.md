# 1.	관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교
##	관계형 데이터베이스 (RDBMS)
  * 데이터는 정해진 스키마에 따라 테이블에 저장된다.
  * 데이터는 관계를 통해 여러 테이블에 분산된다.

## 비관계형 데이터베이스 (NoSQL)
  * Not only SQL. SQL을 사용하지 않는 데이터베이스
  * 스키마도 없고, 관계도 없다. (관계가 없기 대문에 join이라는 개념이 없댜.)


### key - value DB
  * Key-Value 방식으로 데이터를 저장
  * Key값은 모든 데이터 타입을 수용할 수 있고, 중복되지 않는 유니크한 값
  * 간단한 구조인 만큼 속도가 빠른 편이다.
  * 대표적으로 Redis, AWS DynamoDB, Riak 등이 있다.

### Document DB
  * Key-Document 형태로 저장
  * Document는 계층적인 데이터 타입(JSON, XML)으로 저장되는 장점이 있다.
  * JSON 타입을 사용하므로 HTTP 기반의 웹서버의 경우 데이터를 편리하게 주고받을 수 있다.
  * 대표적으로 MongoDB, Couch DB 등이 있다.

## 확장(Scaling)개념
   데이터베이스 서버의 확장성은 수직적 확장과 수평적 확장으로 나누어진다.
   * 수식적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것(CPU 업그레이드)
   * 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미(하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)
  
   RDBMS는 수직적 확장만 지원한다.

### SQL 데이터베이스 사용이 더 좋을 때
* 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우 NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적
* 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### NoSQL 데이터베이스 사용이 더 좋을 때
* 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
* 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
* 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)


# 2.	트랜잭션(transaction)이란 무엇인가요?
데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업단위.
= 여러 개의 쿼리를 하나로 묶는 단위

## ACID (원자성,일관성,독립성,지속성)
### 원자성(Atomicity) = all or nothing
* 트랜젝션이 DB에 모두 반영되거나 혹은 전혀 반영되지 않아야 한다.
* 롤백 수행시 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하며, 트랜잭션 전파를 신경써서 관리해야 함.
ex) 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장한다

  ##### commit
  하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산

  ##### rollback
  * 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우
  * transaction이 정상적으로 종료되지 않았을 때, (예) Transaction의 시작 상태) 로 roll back 할 수 있음.

### 일관성(Consistency)
* 트랜젝션의 작업 처리 결과는 항상 일관성 있어야 한다.

### 독립성(Isolation)
* 둘 이상의 트랜젝션이 동시에 병행 실행되고 있을 때, 어떤 트랜젝션도 다른 트랜젝션 연산에 끼어들 수 없다.
* 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 한다.
  => 순차적으로 하면 쉽겠지만 성능이 떨어짐. 여러 개의 격리 수준으로 나누어 격리성 보장
           데이터 정합성과 성능은 반비례한다.

### 지속성 (Durability)
- 트랜젝션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구할 수 있는 회복 기능이 있어야 함.
- 데이터베이스는 이를 위해 체크섬,저널링,롤백 등의 기능을 제공함

## 격리 수준
추후 코드 추가
### SERIALIZABLE (직렬화 가능)
    특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
    가장 높은 데이터 정합성을 갖지만, 성능은 가장 떨어진다.
    이 격리 수준에서는 단순한 셀렉트 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없다.
### REPEATABLE_READ (반복 가능한 읽기)
    특정 행을 조회시 항상 같은 데이터를 응답하는 것을 보장하는 격리 수준.
    SERIALIZABLE과 다르게 행이 추가되는 것을 막지는 않는다. -> 팬텀 리드 발생   
    ( MySQL의 InnoDB 엔진의 기본 격리 수준.)
### READ_COMMITTED (커밋된 읽기)
    커밋이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용한다.
    특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다.
    특정 트랜잭션에서 데이터가 변경되었으나, 아직 커밋되지 않은 상태라면 
    다른 트랜잭션에서는 해당 데이터에 접근했을 때 트랜잭션 시작 전 데이터를 읽어온다. 커밋이 된 이후에야 변경된 값을 읽어올 수 있다.
    가장 많이 사용되는 격리 수준이며, 오라클 등에서 기본값으로 설정되어 있다.
    팬텀 리드, 반복 가능하지 않은 조회 발생
### READ_UNCOMMITTED (커밋되지 않은 읽기)
    커밋이 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용하나.
    데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다.
    데이터를 어림잡아 집계하는 등의 연산에서 사용하면 좋다.
    팬텀 리드, 반복 가능하지 않은 조회, 더티 리드 등의 문제가 발생한다.


# 3.	MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
하나의 테이블이 아닌 두 개 이상의 테이블을 묶어 하나의 결과물을 만드는 것.
여러 테이블을 조인하는 작업이 많은 경우 관계형 데이터베이스를 사용(MongoDB 등은 lookup시 성능이 떨어짐)
### 내부 조인(inner join)
왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
### 왼쪽 조인(left outer join)
왼쪽 테이블의 모든 행이 결과 테이블에 표기됨. 
만약 오른쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 오른쪽 조인(right outer join)
오른쪽 테이블의 모든 행이 결과 테이블에 표기됨
만약 왼쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 합집합 조인(full outer join)
두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력됨


# 4.	MySQL에서 인덱스(index)란 무엇인가요?
테이블 안의 내가 찾고자 하는 데이터를 빠르게 찾을수 있게 함.
## 인덱스의 종류
### 클러스터형 인덱스 (primary key 옵션 또는 unique not null옵션)
테이블당 하나 설정 가능
### 세컨더리 인덱스 (create index …)
보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성해야 하는 인덱스
### ? 인덱스를 매 필드마다 설정하면 어떻게 될까
* 인덱스는 두번 탐색을 강요한다: 인덱스 리스트 -> 컬렉션
* 읽기 관련 비용이 더 들게 된다.
* 테이블 수정시 인덱스도 수정되어야 한다.
따라서 컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적이다.


### 챌린지를 신청한 이유
프로젝트를 진행하면서, 개발용으로 인메모리 DB는 h2, 운영용으로는 mysql, 캐싱을 위해서는 redis를 사용해왔습니다.
앞서, 이렇게 DB를 선택한 이유는 각 DB가 가장 익숙했기 때문입니다.
앞으로는 프로젝트를 진행하면서 프로젝트 특성에 적합한 DB를 선택하고자 합니다.

또햔, Index를 학교 수업시간에 배우기는 했지만, 언제 사용해야하는지 명확하게 알지 못했는데 
Index 개념 및 사용방법을 배워 Index를 통한 성능최적화를 해보고 싶숩니다.
