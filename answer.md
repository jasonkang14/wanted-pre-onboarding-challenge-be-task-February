## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

### 관계형 데이터베이스(RDBMS) 장점
- 데이터의 성능이 일반적으로 좋아 정렬, 탐색, 분류가 빠름
- 신뢰성이 높아 데이터의 무결성을 보장
- 정규화에 따른 갱신 비용을 최소화

### 관계형 데이터베이스(RDBMS) 단점
- 기존에 작성된 스키마를 수정하기 어려움
- 데이터베이스의 부하를 분석하기 어려움
- 빅테이터를 처리하는데 매우 비효율적임

### 비관계형 데이터베이스(NoSQL)의 장점
- 대용량 데이터 처리를 하는데 효율적임
- 읽기 작업보다 쓰기 작업이 더 빠르고 관계형 데이터베이스에 비해 쓰기와 읽기 성능이 빠름
- 데이터 모델링이 유연함
- 뛰어난 확장성으로 검색에 유리함
- 최적화된 키 값 저장 기법을 사용하여 응답속도나 처리효율 등에서 성능이 뛰어남
- 복잡한 데이터 구조를 표현할 수 있음

### 비관계형 데이터베이스(NoSQL)의 단점
- 쿼리 처리 시 데이터를 파싱 후 연산을 해야해서 큰 크기의 document를 다룰 때는 성능이 저하됨

<hr/>

## 2. 트랜잭션(transaction)이란 무엇인가요?

테이블 갱신을 수행하기 위해 'INSERT/DELETE/UPDATE'를 사용했는데,  
갱신은 단일 쿼리만을 된 것이 아니고 복수 쿼리를 연속적으로 수행하는 경우가 대부분입니다.  
또한, 갱신 전의 데이터로 SELECT를 사용할 때 이를 포함해 복수 쿼리를 일관된 형태의 한덩어리로 다뤄야 합니다.  
>트랜잭션이란 이런 복수 쿼리를 한 단위로 묶은 것입니다.  

트랜잭션은 다음 4가지 특성으로 정의되며 그 앞글자를 따서 `ACID 특성`이라고 합니다.
1. Atomicity(원자성)
2. Consistency(일관성)
3. Isolation(고립성 또는 격리성)
4. Durability(지속성)

<hr/>

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

MySQL은 다른 DBMS보다 조인을 처리하는 방식이 단순하다.  
현재 릴리즈된 **MySQL의 모든 버전에서 조인 방식은 네스티드-루프로 알려진 중첩된 루프와 같은 형태만 지원**한다.  
그리고 조인되는 각 테이블 간의 레코드를 어떻게 연결할지에 따라 여러 가지 종류의 조인으로 나뉜다.  

### 조인의 종류
조인의 종류는 크게 INNER JOIN과 OUTER JOIN으로 구분할 수 있고,  
OUTER JOIN은 다시 LEFT OUTER JOIN과 RIGHT OUTER JOIN 그리고 FULL OUTER JOIN으로 구분할 수 있다.  
그리고 조인의 조건을 어떻게 명시하느냐에 따라 NATURAL JOIN과 CROSS JOIN(FULL JOIN, CARTESIAN JOIN)으로도 구분할 수 있다.

### JOIN (INNER JOIN)
일반적으로 "조인"이라 함은 INNER JOIN을 지칭하는데, 별도로 아우터 조인과 구분할 때 "이너 조인(INNER JOIN)"이라고도 한다.  
MySQL에서  조인은 네스티드-루프 방식만 지원한다.  
>**네스티드-루프**란 일반적으로 프로그램을 작성할 때 두 개의 FOR나 WHILE과 같은 반복 루프 문장을 실행한는 형태로 조인이 처리되는 것을 의미한다.

```
FOR ( record1 IN TABLE1 ) {    //외부 루프 (OUTER)
    FOR ( record2 IN TABLE2 ) { //내부 루프 (INNER)
        IF ( record1.join_column == record2.join_column ) {
            join_record_found(record1.*, record2.*);
        } else {
            join_record_notfound();
        }
    }
}
```
위의 의사 코드에서 알 수 있듯이 조인은 2개의 반복 루프로 두 개의 테이블을 조건에 맞게 연결해주는 작업이다.(이 의사 코드의 FOR 반복문이 풀 테이블 스캔을 의미하는 것은 아니다.)  
두 개의 FOR 문장에서 바깥쪽을 아우터 테이블이라고 하며, 안쪽을 이너 테이블이라고 표현한다.  
또한 아우터 테이블은 이너 테이블보다 먼저 읽어야 하며, 조인에서 주도적인 역할을 한다고 해서 드라이빙 테이블이라고도 한다.  
이너 테이블은 조인에서 끌려가는 역할을 한다고 해서 드리븐 테이블이라고도 한다.

중첩된 반복 루프에서 최종적으로 선택될 레코드가 안쪽 반복 루프 (INNER TABLE)에 의해 결정되는 경우를 INNER JOIN이라고 한다.  
즉, 두 개의 반복 루프를 실행하면서 TABLE2(INNER TABLE)에 "IF ( record1.join_column == record2.join_column )" 조건을 만족하는 레코드만 조인의 결과로 가져온다.

OUTER JOIN, 카테시안 조인, NATURAL JOIN, Single-sweep multi join, 조인 버러플 이용한 조인(Using join buffer) 방식의 조인들이 있다.

<hr/>

## 4. MySQL에서 인덱스(index)란 무엇인가요?

많은 사람이 인덱스를 언급할 때는 항상 책의 제일 끝에 있는 찾아보기(또는 "색인")로 설명하곤 한다.  
책의 마지막에 있는 "찾아보기"가 인덱스에 비유된다면 책의 내용은 데이터 파일에 해당한다고 볼 수 있다.  
책의 찾아보기를 통해 알아낼 수 있는 페이지 번호는 데이터 파일에 저장된 레코드의 주소에 비유될 것이다.  
DBMS도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.  
그래서 칼럼(또는 칼럼들)의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍(key-Value pair)으로 인덱스를 만들어 두는 것이다.  
그리고 책의 "찾아보기"와 DBMS의 인덱스의 공통점 가운데 중요한 것이 바로 정렬이다.  
책의 찾아보기도 내용이 많아지면 우리가 원하는 검색어를 찾아내는 데 시간이 오래 걸릴 것이다.  
그래서 최대한 빠르게 찾아갈 수 있게 "ㄱ", "ㄴ", "ㄷ", ...와 같은 순서대로 정렬돼 있는데,   
DBMS의 인덱스도 마찬가지로 칼럼의 값을 주어진 순서로 미리 정렬해서 보관한다.

데이터 저장 방식(알고리즘)별로 구분하는 것은 사실 상당히 많은 분류가 가능하겠지만 대표적으로 **B-Tree** 인덱스와 **Hash** 인덱스로 구분할 수 있다.  


