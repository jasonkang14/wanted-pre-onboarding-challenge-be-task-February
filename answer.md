1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- RDBMS(Relational Database Management System)?
  RDB를 관리하는 시스템이다. RDB는 관계형 데이터 모델을 기초로 두고 모든 데이터를 2차원 테이블 형태로 표현하는 데이터베이스다.

  - 특징
    - 다른 테이블들과 관계를 맺고 모여있는 집합체이며 테이블 간 조인이 가능함.
    - 트랜잭션 처리가 가능함.
  - RDBMS의 장단점

  - 장점
    - **정해진 스키마에 따라** 저장해야 하므로 명확한 데이터 구조를 보장한다.
    - 데이터를 중복없이 저장할 수 있다.
    - **트랜잭션** 처리가 가능하다.
  - 단점
    - 스키마로 인해 데이터가 유연하지 못하다.
    - 테이블 간 관계를 맺고 있어 시스템이 커지면 JOIN 문이 많은 복잡한 쿼리가 만들어질 수 있다.
    - 성능 향상을 위해서는 scale-up만을 지원한다.

- NoSQL(Not Only SQL)?
  대용량의 데이터를 분산 처리하는 데이터베이스 시스템이다.

  - 특징

    - 미리 테이블을 생성 할 필요가 없으며 일반적으로 join은 불가능함.

  - NoSQL의 장단점
    - 장점
      - **스키마가 없어** 자유로운 데이터 구조를 가질 수 있다.
      - 새로운 필드 추가시에 용이하다.
      - **데이터 분산**이 용이하며 성능 향상을 위한 scale-up과 scale-out이 가능하다.
    - 단점
      - 데이터 중복 발생 가능성이 있다.
      - 명확한 데이터 구조를 보장하지 않는다.
      - 트랜잭션이 보장되지 않는다.

2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션?

  - 단위로 처리되는 일련의 작업이다.
  - 작업의 완전성을 보장해준다.
  - 사용자의 입장에서는 작업의 논리적 단위로 이해할 수 있고 시스템의 입장에서는 데이터들을 접근 또는 변경하는 프로그램의 단위가 된다.

- 트랜잭션의 기본속성(ACID)

  - Atomicity(원자성): 트랜잭션 작업이 모두 수행되거나 전혀 수행되지 않아야함.
  - Consistency(일관성) : 트랜잭션 수행 이후에도 데이터는 항상 일관되고 무결성이 유지된 상태에 있어야 함.
  - Isolation(독립성) : 각 트랜잭션은 다른 트랜잭션의 수행에 영향을 끼치면 안된다.
  - Durability(지속성) : 한번 commit된 트랜잭션의 결과는 계속적으로 유지되어야한다.

- SQL 표준에서의 트랜잭션
  - commit : 트랜 잭션 종료
  - roll back : 트랜잭션 취소
  - auto commit : SQL 문장 하나 단위로 transaction

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- RDBMS에서의 JOIN

  RDBMS에서는 중복 데이터를 피하기위해서 여러 **테이블로 나눠서 저장**한다. 분리되어 저장된 데이터에서 원하는 결과를 다시 도출하기 위해서 **여러 테이블을 조합**할 필요가 있다. 이때 JOIN 연산자를 사용해 관련있는 칼럼을 기준으로 행을 합쳐주는 연산을 수행한다.

- MySQL에서의 JOIN
  - MySQL에서 지원하는 JOIN 연산
    - INNER JOIN
      - CROSS JOIN - CARTESIN JOIN
      - EQUI JOIN
      - NON-EQUI JOIN
      - NATURAL JOIN
    - OUTER JOIN
      - FULL OUTER JOIN
      - LEFT OUTER
      - RIGHT OUTER
    - SELF JOIN
    - ANTI JOIN
    - SEMI JOIN
  - `JOIN`, `CROSS JOIN`, and `INNER JOIN`은 동일하다. (서로 대체가능하다.)

4. MySQL에서 인덱스(index)란 무엇인가요?

- RDBMS에서의 인덱스

  - RDBMS는 단순히 데이터를 저장하는게 아니라 저장된 데이터를 가지고 서비스 해야한다. 데이터를 하나하나 검사하게 되면 **검색 성능**이 떨어지는 문제가 발생한다. 이 문제를 해결하기 위한 기술이 인덱스다.
  - **데이터를 효율적으로 접근**하는 것을 지원하기 위한 데이터 구조다.
  - INSERT, UPDATE, DELETE의 성능을 희생하고 그 대신에 **데이터의 읽기 속도**를 높이는 테이블의 동작속도를 높여주는 자료구조다.
    - 왜 추가, 수정, 삭제 성능을 희생해야할까?
      추가, 수정, 삭제시 생성된 인덱스에도 데이터 동기화를 해줘야하는데 이 과정에서 오버헤드가 생긴다.

- MySQL에서의 index
  - 대부분의 MySQL 인덱스(PRIMARY KEY, UNIQUE, INDEX, FULLTEXT)는 **B-tree**안에 저장된다.
  - 종류
    - **Clustered Index**
      테이블 레코드들이, 인덱스 칼럼의 정렬 순서대로 적재되어 있는 것. 인덱스 자체가 테이블 레코드 순서와 같다
    - **Secondary Index (보조 인덱스)**
