# 1.	관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교
##	관계형 데이터베이스 (RDBMS)

---
  * 데이터는 정해진 스키마에 따라 테이블에 저장된다.
  * 데이터는 관계를 통해 여러 테이블에 분산된다.

    데이터는 테이블에 레코드로 저장된다.
    또한 테이블마다 명확하게 정의가 된 구조가 있는데, 스키마를 준수하지 않은 레코드는 테이블에 추가할 수 없다.

## 비관계형 데이터베이스 (NoSQL)

---
  * Not only SQL. SQL을 사용하지 않는 데이터베이스
  * 스키마도 없고, 관계도 없다. (관계가 없기 대문에 join이라는 개념이 없다.)
  * NoSQL에서는 레코드를 문서(document)라고 부른다.

### SQL과 차이점
1. SQL은 정해진 스키마를 따르지 않으면 데이터 추가가 불가능 했다.
   하지만, NoSQL에서는 다른 구조의 데이터를 같은 컬렉션에 추가 가능하다.
2. 관계형 데이터베이스처럼 여러 테이블에 나누어 담지 않고, 관련 데이터를 동일한 컬렉션에 넣는다고 했는데 따라서 여러 테이블을 조인할 필요가 없다.
        

### key - value DB
  * Key-Value 방식으로 데이터를 저장
  * Key값은 모든 데이터 타입을 수용할 수 있고, 중복되지 않는 유니크한 값
  * 간단한 구조인 만큼 속도가 빠른 편이다.
  * 대표적으로 Redis, AWS DynamoDB, Riak 등이 있다.

### Document DB
  * Key-Document 형태로 저장
  * Document는 계층적인 데이터 타입(JSON, XML)으로 저장되는 장점이 있다.
  * JSON 타입을 사용하므로 HTTP 기반의 웹서버의 경우 데이터를 편리하게 주고받을 수 있다.
  * 대표적으로 MongoDB, Couch DB 등이 있다.

## 확장(Scaling)개념

---
   데이터베이스 서버의 확장성은 수직적 확장과 수평적 확장으로 나누어진다.
   * 수식적 확장 : 단순히 데이터베이스 서버의 성능을 향상시키는 것(CPU 업그레이드)
   * 수평적 확장 : 더 많은 서버가 추가되고 데이터베이스가 전체적으로 분산됨을 의미(하나의 데이터베이스에서 작동하지만 여러 호스트에서 작동)
  
   RDBMS는 수직적 확장만 지원한다.

## SQL

---

### SQL의 장점
1. 명확하게 정의된 스키마 따라서 데이터 무결성을 보장한다.
2. 관계를 맺고있기 때문에 데이터를 중복없이 저장한다.

### SQL의 단점
1. 덜 유연하다. 데이터 스미카를 사전에 계획해야 한다.그로 인해 나중에 수정하기 힘들다.
2. 관계를 맺고있어 조인문이 많은 복잡한 쿼리가 만들어질 수 있다.
3. 수직적 확장만 가능하다.

## NoSQL

---
### NoSQL의 장점
1. 스키마가 없어서 유연하다. 따라서 새로운 필드 추가가 상대적으로 쉽다.
2. 데이터는 애플리케이션이 필요로 하는 형식으로 저장된다. 따라서 데이터 읽어오는 속도가 빠르다.
3. 수직 및 수정 확장이 가능하다.

### NoSQL의 단점
1. 데이터가 여러 컬렉션에 중복되어 있기 때문에 수정 시 모든 컬렉션에서 수정해야 한다.
   cf) SQL에서는 중복 데이터가 없기 때문에 한 번만 수정하면 된다.

## SQL vs NoSQL 언제 사용해야할까

---

### SQL 데이터베이스 사용이 더 좋을 때
* 관계를 맺고 있는 데이터가 자주 변경되는 애플리케이션의 경우 NoSQL에서는 여러 컬렉션을 모두 수정해야 하기 때문에 비효율적
* 변경될 여지가 없고, 명확한 스키마가 사용자와 데이터에게 중요한 경우

### NoSQL 데이터베이스 사용이 더 좋을 때
* 정확한 데이터 구조를 알 수 없거나 변경/확장 될 수 있는 경우
* 읽기를 자주 하지만, 데이터 변경은 자주 없는 경우
* 데이터베이스를 수평으로 확장해야 하는 경우 (막대한 양의 데이터를 다뤄야 하는 경우)


# 2. 트랜잭션(transaction)이란 무엇인가요?
## 트랜젝션이란?

---
> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
> 
> = 여러 개의 쿼리를 하나로 묶는 단위

* 상태를 변화시키는 것 -> SQL을 통해 DB에 접근
  * SELECT, INSERT, DELETE, 
* 작업 단위 -> 여러 개의 SQL 쿼리
> 예시) 사용자 A가 사용자 B에게 만원을 송금한다.
> 
> 이때, 작업 단위는 
> 1. 사용자 A가 계좌에서 만원을 차감한다. -> UPDATE문을 사용해서 사용자 A의 잔고 변경
> 2. 사용자 B의 계좌에 만원을 추가한다. -> UPDATE문을 사용해서 사용자 B의 잔고 변경

* 이 두 쿼리를 합쳐서 하나의 트랜젝션이라고 한다.
* Commit : 이 두 쿼리를 모두 성공해야 하나의 작업(트랜젝션)이 완료된다.
* Rollback : 작업 단위에 속하는 쿼리 중 하나라도 실패하면 모든 쿼리를 취소하고 이전 상태로 되돌린다.
        

## ACID (원자성,일관성,독립성,지속성)

---
### 원자성(Atomicity) = all or nothing
* 트랜젝션이 DB에 모두 반영되거나 혹은 전혀 반영되지 않아야 한다.
* 롤백 수행시 어떻게 해야 할 것인지에 대한 해결 방법이 있어야 하며, 트랜잭션 전파를 신경써서 관리해야 함.
ex) 트랜잭션을 커밋했는데, 문제가 발생하여 롤백하는 경우 그 이후에 모두 수행되지 않음을 보장한다

  * #### commit
  하나의 트랜잭션이 성공적으로 끝났고, DB가 일관성있는 상태일 때 이를 알려주기 위해 사용하는 연산

  * #### rollback
  * 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션 원자성이 깨진 경우
  * transaction이 정상적으로 종료되지 않았을 때, (예) Transaction의 시작 상태) 로 roll back 할 수 있음.

### 일관성(Consistency)
* 트랜젝션의 작업 처리 결과는 항상 일관성 있어야 한다.

### 독립성(Isolation)
* 둘 이상의 트랜젝션이 동시에 병행 실행되고 있을 때, 어떤 트랜젝션도 다른 트랜젝션 연산에 끼어들 수 없다.
* 복수의 병렬 트랜잭션은 서로 격리되어 마치 순차적으로 실행되는 것처럼 작동되어야 한다.
  => 순차적으로 하면 쉽겠지만 성능이 떨어짐. 여러 개의 격리 수준으로 나누어 격리성 보장
           데이터 정합성과 성능은 반비례한다.

### 지속성 (Durability)
- 트랜젝션이 성공적으로 완료되었으면, 결과는 영구적으로 반영되어야 한다.
- 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구할 수 있는 회복 기능이 있어야 함.
- 데이터베이스는 이를 위해 체크섬,저널링,롤백 등의 기능을 제공함

## 트렌젝션 격리 수준(Transaction Isolation Level)

---
### Isolation Level
트랜젝션에서 일관성 없는 데이터를 허용하는 수준

### Isolation Level의 필요성
데이터베이스는 트랜젝션이 독립적인 수행을 하도록 허용한다.
따라서 Locking을 통해 트랜젝션이 DB를 다루는 동안 다른 트랜젝션이 DB를 관여하지 못 하도록 막아야 한다.

하지만, 무조건 Locking으로 동시에 수행되는 수많은 트랜젝션들을 하나만 접근하도록 하여 순차적으로 실행하도록 하는 것은 데이터베이스의 성능을 떨어지게 한다.
그렇다고 해서 성능을 높이기 위해 Locking의 범위를 줄이면 잘못된 값이 처리될 수 있다.


따라서 적절한 Locking방법을 사용하는 것이 중요하다.

## Isolation Level 종류

---
### SERIALIZABLE (직렬화 가능)
* 특정 트랜잭션이 사용중인 테이블의 모든 행을 다른 트랜잭션이 접근할 수 없도록 잠근다.
* 가장 높은 데이터 정합성을 갖지만, 성능은 가장 떨어진다. 
  * 이 격리 수준에서는 단순한 셀렉트 쿼리가 실행되더라도, 데이터베이스 락이 걸려 다른 트랜잭션에서 데이터에 접근할 수 없다.
### Repeatable Read (반복 가능한 읽기)
<img width="497" alt="image" src="https://user-images.githubusercontent.com/88534959/216823524-e3ecf299-6122-49cc-a04a-75a4bd87956b.png">

* 하나의 트랜잭션이 읽은 로우를 다른 트랜잭션이 수정할 수 없도록 막아준다. 

    하지만 새로운 로우를 추가하는 것은 막지 않는다. 따라서 SELECT로 조건에 맞는 로우를 전부 가져오는 경우 트랜잭션이 끝나기 전에 추가된 로우가 발견될 수 있다.

* 자신의 트랜잭션 번호(ID)보다 낮은 트랜젝션 번호에서 변경된(Commit)된 것만 읽고
* 자신의 트랜젝션 번호보다 높은 트랜젝션에서 변경된 것은 UNDO 영역에서 백업된 레코드를 읽는다.
* 하지만, UNDO 영역에 백업된 레코드가 많아지면 성능이 떨어질 수 있다.
### Read Committed(커밋된 읽기)
<img width="495" alt="image" src="https://user-images.githubusercontent.com/88534959/216823375-f144f853-fba6-4464-8421-f8b1198b6272.png">

* Commit이 완료된 트랜잭션의 변경사항만 다른 트랜잭션에서 조회할 수 있도록 허용한다.

    특정 트랜잭션이 이루어지는 동안 다른 트랜잭션은 해당 데이터에 접근할 수 없다.
* Commit 되기 전에는 UNDO 영역에 백업된 레코드(트랜젝션 시작 전 데이터)에서 값을 가져온다.
* 이후 Commit이 완료된 이후에야 변경된 값을 읽어올 수 있다.
> 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 해당 데이터에 접근이 불가능함
### Read Uncommitted (커밋되지 않은 읽기)
<img width="510" alt="image" src="https://user-images.githubusercontent.com/88534959/216823060-3b352973-4ff7-4525-9192-a7ca02bfc773.png">

* Commit 되지 않은 트랜잭션의 데이터 변경 내용을 다른 트랜잭션이 조회하는 것을 허용
* 데이터 부정합 문제가 발생할 확률이 높지만, 성능은 가장 빠르다.
> 사용자1이 A라는 데이터를 B라는 데이터로 변경하는 동안 사용자2는 아직 완료되지 않은(Uncommitted) 트랜잭션이지만 데이터B를 읽을 수 있다


<img width="625" alt="image" src="https://user-images.githubusercontent.com/88534959/216826438-fa88c7c5-fdcc-4de6-88f9-17e192985c3f.png">

* 하지만 Dirty Read 문제점이 발생한다.
* Dirty Read : A가 한 데이터를 변경한 후 Rollback 했을 때 발생

## 트랜젝션 전파(propagation)

---
* 트랜젝션 전파는 어떤 트랜젝션이 동작중인 과정에서 다른 트랜젝션을 실행할 경우 어떻게 처리하는가에 대한 개념이다.
* 트랜젝션이 끝나는 방법은 작업을 혹정짓는 commit과 모든 작업을 무효화하는 rollback이 있다.

//todo : 코드 추가
### REQUIRED

* default 값이기 때문에 생략가능
이미 진행중인 트랜젝션(부모 트랜젝션)이 존재할 때 자식 트랜젝션은 거기에 합류하고, 부모 트랜젝션이 존재하지 않으면 자식 트랜젝션은 새 트랜젝션을 생성하는 것이다.

ex) 자전거 살 돈을 사장님께 지불한다 -> 자전거를 받는다.

자전거를 받는 트랜젝션에서 예외가 발생해 해당 트랜젝션이 롤백이 된다면, 자전거를 받지 못했기 때문에 사장님께 지불한 돈도 롤백이 되어야 한ㄷ.

B는 트랜젠션 레벨이 REQUIRED이기 때문에 부모 트랜젝션에 합류된 상태로 진행됐다. 따라서 B연산이 롤백되면 A연산도 롤백된다.

### REQUIRED_NEW
이미 진행중인 트랜젝션(부모 트랜젝션)이 존재할 때 부모 트랜젝션을 중단하고 별도로 자식 트랜젝션을 진행하고, 부모 트랜젝션이 존재하지 않은면 자식 트랜젝션은 새 트랜젝션을 생성하는 것이다.

ex) 댓글을 작성(A) -> 사용자에게 알림을 보내준다.(B)

만약 A,B가 REQUIRED라면 알림기능(B)에서 예외가 발생하여 트랜젝션이 롤백되면, 작성한 댓글(A)도 롤백된다.

하지만, A는 REQUIRED B는 REQUIRED_NEW라면 알림(B)에서 예외가 발생하여 트랜젝션이 롤백되더라도, 작성한 댓글(A)은 롤백되지 않는다.


# 3.	MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
서로 다른 테이블에서 데이터를 가져올 때 사용하는 것이 join이다.
여러 테이블을 조인하는 작업이 많은 경우 관계형 데이터베이스를 사용(MongoDB 등은 lookup시 성능이 떨어짐)
### 내부 조인(inner join)
왼쪽 테이블과 오른쪽 테이블의 두 행이 모두 일치하는 행이 있는 부분만 표기
### 왼쪽 조인(left outer join)
왼쪽 테이블의 모든 행이 결과 테이블에 표기됨. 
만약 오른쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 오른쪽 조인(right outer join)
오른쪽 테이블의 모든 행이 결과 테이블에 표기됨
만약 왼쪽 테이블에 일치하는 항목이 없는 경우 해당값은 null이 된다.
### 합집합 조인(full outer join)
두 개의 테이블을 기반으로 조인 조건에 만족하지 않는 행까지 모두 표기
이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력됨


# 4. MySQL에서 인덱스(index)란 무엇인가요?
### 인덱스란

---
데이터의 저장(INSERT, UPDATE, DELETE)의 성능을 희생하고 그 대신에 데이터의 읽기 속도를 높이는 자료구조

### 인덱스가 필요한 이유

---
인덱스는 데이터베이스의 속도 측면의 성능을 향상시키기 위해서 사용한다.

어떤 항목을 select하는데 몇분이 걸리던 것이 인덱스를 이용해 조회하면 0.*초 단위로 끝낼 수 있을 정도이다.

따라서 index를 사용하는 SQL을 만들어 효율적으로 사용한다면 매우 빠른 응답 속도를 얻을 수 있고, 쿼리의 부하가 줄어들어 시스템 전체 성능이 향상되는 효과를 얻는다.

하지만, 인덱스도 하나의 데이터이기 때문에 데이터베이스에 전체 크기의 10%나 되는 추가적인 공간을 할당해주어야 한다. 
또한 변경작업이 자주 일어나는 경우 성능이 오히려 떨어질 수 있다.

## 인덱스의 특징

---
### 인덱스의 장점
* select(조회) 성능을 향상
* 쿼리 부하가 줄어들어, 시스템 전체 성능이 향상

### 인덱스의 단점
* 인덱스 생성 시 DB 크기의 약 10%정도의 추가 공간 필요
* 처음 인덱스 생성시 시간이 많이 소요됨
* insert, update, delete 같은 데이터 변경 쿼리가 잦은 경우 성능이 악화될 수 있음


## 인덱스 타입 종류

---
클러스터 인덱스는 처음부터 정렬이 되어있는 영어 사전과 같은 개념이고,

보조 인덱스는 책 뒤의 찾아보기의 개념과 비슷하다.

<img width="699" alt="image" src="https://user-images.githubusercontent.com/88534959/217199344-c29c95a7-833c-471f-9008-cc04e9336f25.png">
MYSQL은 데이터를 한 곳에다가 다 저장하는 것이 아닌, 페이지(page)단위로 쪼개어 저장한다. 이때 페이지 크기의 기본 단위는 16KB정도이다.

### Clustered INDEX
#### Clustered INDEX 특징
* 데이터를 일정 기준으로 정렬해주는 인덱스(ex : 영어사전) 그래서 클러스터형 인덱스 생성 시에는 데이터 페이지 전제가 다시 정렬된다.
* 따라서 대용량의 데이터가 입력된 상태라면 클러스터형 인덱스 생성은 심각한 시스템 부하를 줄 수 있다.
* 한 개의 테이블에 한 개씩만 만들 수 있다.(PK)

<img width="670" alt="image" src="https://user-images.githubusercontent.com/88534959/217200298-983c2fd1-aee8-401f-b07b-2ebc94f20c5c.png">

* 인덱싱을 하면 루트 페이지가 만들어진다. 루트 페이지는 각 데이터 페이지의 첫 번째 데이터만 가지고 와서 매핑시키는 페이지이다.
* 중간중간 브랜치 페이지가 있으며, 맨 마지막인 리프페이지는 정렬된 상태의 데이터 페이지가 저장된다.
* 따라서 데이터 페이지 자체를 인덱스 페이지로 한다.

#### Clustered INDEX를 이용한 조회
만일 JKW를 찾고 싶으면 2페이지만 조회하면 된다.
<img width="743" alt="image" src="https://user-images.githubusercontent.com/88534959/217201286-47422862-5be9-4e55-b7e3-5ddc052536fd.png">

#### Clustered INDEX를 이용한 삽입

<img width="741" alt="image" src="https://user-images.githubusercontent.com/88534959/217201555-24017121-b999-41e2-9a00-49210431b469.png">
* FNT 데이터를 추가하는데 1000페이지에 공간이 없기 때문에 페이지 분할이 일어난다. 이로인해 2000번 페이지가 생성되었다.
* KAI는 KBS 앞에 위치하기 때문에 2000번 페이지에 저장된다.
* 이처럼 데이터를 추가할 때마다 정렬을 하기 때문에 삽입/삭제를 할 때 페이지 분할이 일어나 추가적인 정렬이 필요해 성능이 나빠질 수 있다.

### Secondary INDEX
#### Secondary INDEX 특징
* 별도의 페이지에서 인덱스를 구성하고, 클러스터와는 달리 정렬을 하지 않는다.
* 보조 인덱스는 여러 개 생성할 수 있다. 
* 클러스터형보다 검색 속도는 더 느리지만 데이터의 입력/수정/삭제는 덜 느리다.

<img width="428" alt="image" src="https://user-images.githubusercontent.com/88534959/217247597-ead0b436-f511-4acb-9a11-e38e748e7298.png">

* 데이터 페이지와 별도로 인덱스 페이지가 생성된다. 하지만 루트 페이지는 데이터 페이지와 바로 매핑되지 않고 따로 리프 페이지를 만들어 매핑하고 정렬한다.
* 이처럼 추가 공간이 필요하므로 인덱스를 남용하면 공간 낭비로 이어진다.
* 데이터 페이지는 변화가 없다.

#### Secondary INDEX를 이용한 조회
만일 JKW를 찾고 싶다면 3페이지를 뒤져야 한다.
<img width="697" alt="image" src="https://user-images.githubusercontent.com/88534959/217248775-41742d02-c21b-4330-a782-d1697209bb3e.png">

#### Secondary INDEX를 이용한 삽입
페이지 빈 곳에 데이터를 넣고 리프 페이지에서 매핑만 하면 되기 때문에, 페이지 분하링 일어나지 않는다.

따라서 삽입 측면에서 클러스터형 인덱스보다 성능 이점을 가지게 된다.(페이지 분할이 일어나지 않는다는 가정하에)

//todo
(의문!!) 그런데 아래와 같은 경우에서 KAA가 삽입된다고 하면, 100번에 들어가야 하는데 100번이 다 찾으므로 이때도 어차피 페이지 분할이 일어나야 한다. 
* 데이터 페이지에서의 분할이 아니라 인덱스 페이지에서 분할은 따로 보는 것인가? 
* 그럼 여기서는 데이터 페이지 분할에만 집중하는 것인가? 이유는?
<img width="703" alt="image" src="https://user-images.githubusercontent.com/88534959/217249245-2776170d-269c-47db-960e-304fb521b407.png">



### 챌린지를 신청한 이유

---
프로젝트를 진행하면서, 개발용으로 인메모리 DB는 h2, 운영용으로는 mysql, 캐싱을 위해서는 redis를 사용해왔습니다.
앞서, 이렇게 DB를 선택한 이유는 각 DB가 가장 익숙했기 때문입니다.
앞으로는 프로젝트를 진행하면서 프로젝트 특성에 적합한 DB를 선택하고자 합니다.

또햔, Index를 학교 수업시간에 배우기는 했지만, 언제 사용해야하는지 명확하게 알지 못했는데 
Index를 적용해야 할 상황을 알아보고, Index를 통한 성능 최적화를 하고 싶습니다.
