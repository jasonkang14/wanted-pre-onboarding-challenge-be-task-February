1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

   - **관계형 데이터베이스 (RDBMS)** 는 모든 데이터를 2차원 테이블 형태로 표현합니다.<br>
    
     - **장점**
       1. 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있습니다. 
       2. 이는 정규화 과정을 통해 중복을 제거하고 테이블들을 분리하여 관계형으로 묶으면서 이상현상(Anomaly)를 제거해 데이터의 무결성, 정합성을 지킬 수 있습니다. 
       3. 따라서, 데이터가 자주 변경이 이루어지는 시스템에 적합합니다. 
       
       <br>

     - **단점**
       1. 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하됩니다. 
       2. 데이터 구조가 명확하지 않고 변경 될 여지가 많을 경우 사용하는 것이 부적합합니다. 
       3. 또한, 서버의 확장의 경우 서버 성능 올리는 Scale-up의 경우 용이하지만, 서버의 대수를 늘리는 Scale-out은 어렵습니다.

    <br>

   - **NoSQL (Not Only SQL)** 은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.<br>

     - **장점**
       1. 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있습니다. 
       2. 데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능합니다.
       
       <br>

     - **단점**
       1. 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 합니다. 
       2. 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있습니다. 
       3. 따라서 Update가 많이 이루어지는 시스템에는 모든 컬렉션에서 수정해야 하기에 부적합 합니다.

    <br><br>

2. 트랜잭션(transaction)이란 무엇인가요?
   - **트랜잭션** 이란?
      1. 트랜잭션은 작업의 완전성을 보장해줍니다.
      
      2. 하나의 트랜잭션은 Commit(작업완료)되거나 Rollback(취소)됩니다.
      
      3. 즉, 작업들을 모두 처리하거나 처리하지 못할 경우 이전 상태로 복구하여 작업의 일부만 적용되는 현상이 발생하지 않게 만들어주는 기능입니다.
      
      4. 복수의 트랜잭션을 사용하면 교착상태가 일어날 수 있습니다.
      
      5. 교착상태란 두 개 이상의 트랜잭션이 특정 자원(My SQL에서는 테이블 또는 행)의 잠금을 획득한 채 다른 트랜잭션을 소유하고 있는 잠금을 요구하면 계속 대기 상태로 있는 것을 교착상태라고 합니다.
         
    <br>

   - **트랜잭션의 특성 (ACID)**
        1. **원자성(Atomicity)**
           - 작업이 모두 반영되던지 아니면 전혀 반영되지 않음
        
            <br>
        2. **일관성(Consistency)** 
           - 실행이 완료되면 언제나 일관성 있는 상태를 유지

            <br>
        3. **독립성(Isolation)** 
           - 둘 이상 트랜잭션이 동시에 실행될 경우 서로의 연산에 끼어들 수 없음

            <br>
        4. **영속성(Durability)**
           - 완료된 결과는 영구적으로 반영

    <br><br>

   - **트랜잭션의 상태**
     1. **Active**
        - 트랜잭션의 활동 상태. 트랜잭션이 실행중이며 동작중인 상태
        
        <br>
     2. **Failed**
        - 트랜잭션 실패 상태. 트랜잭션이 더이상 정상적으로 진행 할 수 없는 상태

        <br>
     3. **Partially Committed**
        - 트랜잭션의 Commit 명령이 도착한 상태. 
        - 트랜잭션의 commit 이전 sql문이 수행되고 commit만 남은 상태
     
        <br>
     4. **Committed** 
        - 트랜잭션 완료 상태. 
        - 트랜잭션이 정상적으로 완료된 상태
      
        <br>
     5. **Aborted**
        - 트랜잭션이 취소 상태. 트랜잭션이 취소되고 트랜잭션 실행 이전 데이터로 돌아간 상태
      
        <br>
     6. **Partially Committed 와 Committed 의 차이점**
        - Commit 요청이 들어오면 상태는 Partially Commited 상태 
        - Commit을 문제 없이 수행할 수 있으면 Committed 상태로 전이되어 정상적으로 완료
        - 만약 오류가 발생하면 Failed 상태

    <br><br>

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.
   
   - **조인(join)** 이란?
     1. 조인은 두 개의 테이블을 서로 묶어서 하나의 결과를 만들어 내는 것을 말합니다.
        
     2. 두 테이블의 조인을 위해서는 기본키(PRIMARY KEY, PK)와 외래키(FOREIGN KEY, FK) 관계로 맺어져야 합니다.

     <br>

   - **조인(join)** 의 종류
     1. **inner join**
        - 서로 연관된 내용만 검색하는 조인 방법입니다.
        - A와 B에 대해 수행하는 것은, A와 B의 교집합을 말합니다.
        - 두 테이블을 조인할 때, 두 테이블에 모두 지정한 열의 데이터가 있어야 합니다.
        - 같은 방법으로 natural join도 있습니다.

        <br>

     2. **outer join**
        - 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법입니다. 
        - A와 B에 대해 수행하는 것은, A와 B의 합집합을 말합니다.
        - left outer join, right outer join, full outer join이 있습니다.
        
        <br>

     3. **cross join**
        - 한쪽 테이블의 모든 행과 다른 쪽 테이블의 모든 행을 조인하는 기능입니다.
        - A * B 테이블의 행 개수 만큼의 데이터를 가진 테이블이 조회됩니다.

        <br>

     4. **self join**
        - 자신이 자신과 조인한다는 의미로, 1개의 테이블을 사용합니다.

        <br><br>  

4. MySQL에서 인덱스(index)란 무엇인가요?
   - **인덱스(index)** 란? 
     1. 테이블을 처음부터 끝까지 검색하는 방법인 FTS(Full Table Scan)과는 달리 인덱스를 검색하여 해당 자료의 테이블을 엑세스 하는 방법입니다.
         
     2. 예를 들어, DB를 책으로 비유하면 데이터는 책의 내용, 데이터가 저장된 레코드의 주소는 index 목록에 있는 페이지 번호입니다.

     3. 인덱스는 항상 정렬된 상태를 유지하기 때문에 원하는 값을 검색하는데 빠릅니다.
        
     4. 하지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.
        
     5. 즉, 인덱스는 데이터의 저장 성능을 희생하고 그대신 데이터의 검색 성능을 높이기 위해 임의의 규칙으로 정렬해 놓은 자료구조라 할 수 있습니다.

     6.  인덱스는 항상 최신의 정렬 상태를 유지해야 합니다.

     7.  인덱스도 하나의 데이터베이스 객체로서 데이터베이스 크기의 약 10% 정도의 저장 공간 필요합니다.
        
        <br>

   - 인덱스의 종류
     1. **클러스터드 인덱스(clustered index)**
        - 인덱스는 실제 데이터와 같은 무리의 인덱스

        - 실제 데이터 자체가 정렬되는 인덱스

        - 테이블 당 하나만 존재 가능합니다.
          
        - 예시로는 책의 페이지 번호나 글자 순으로 정렬된 사전을 예를 들 수 있습니다.
        
        <br>
        
     2. **논 클러스터드 인덱스(non-clustered index)**
        - 인덱스는 실제 데이터와 다른 무리의 별도의 인덱스

        - 별도의 인덱스 페이지가 생성되는 인덱스

        - 테이블 당 여러 개가 존재 가능합니다.

        - 실제 데이터 탐색에 도움을 주는 별도의 찾아보기 페이지, 책 맨 뒷장에 키워드로 정리된 페이지