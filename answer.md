## 1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- RDBMS(SQL)
  
  - 장점
    
    - 데이터 스키마, 데이터간 관계가 정형화되어 테이블, 컬럼간 관계를 명확하게 표현합니다.
      
    - 데이터의 일관성을 보장하므로 신뢰성이 있는 시스템 구축에 적합합니다.
      
  - 단점
    
    - 데이터간 관계와 데이터의 양은 비례됩니다. 이로 인해 데이터의 양이 많아질 수록 데이터 CRUD에 비효율적인 현상이 발생합니다.
      
    - 데이터의 확장이 수직적으로 일어납니다. 이로 인해 메모리, CPU 등 비용의 소모가 큽니다.
      
- NoSQL
  
  - 장점
    
    - 데이터간 관계, 데이터 스키마를 메타데이터로서 따로 관리하기 때문에 데이터의 수평적 확장, 데이터 스키마 변경에 용이합니다.
      
    - 수평적 확장으로 RDBMS보다 값싼 비용으로 확장이 가능합니다.
      
  - 단점
    
    - 설계가 매우 어렵습니다. 관계가 명시적으로 존재하지 않기 때문에 사용자에게 모든 책임이 있습니다.
      
    - `CAP` 정리에 의해 시스템 목적에 따라 희생해야할 특성을 선택합니다. 이로 인한 추가적인 보완이 필요합니다.
      

## 2. 트랜잭션(transaction)이란 무엇인가요?

#### 트랜잭션

> 데이터베이스의 상태를 변화시키기 위해 수행하는 작업 단위
> 
> 쪼갤 수 없는 업무 처리의 최소 단위 트랜잭션을 통해 데이터베이스의 완전성(intergrity) 유지를 확신

- 상태를 변화 = SQL 질의어를 통해 DB에 접근하는 것
  
  - `SELECT` , `INSERT` , `DELETE` , `UPDATE`와 같은 작업
- 작업 단위 = 사용자가 특정 기능의 수행을 위해 SQL작업을 묶는 단위
  
- 쪼갤 수 없는 업무 처리 = 여러개의 클라이언트가 액세스하거나, DB를 갱신 처리하는 과정에서 중단되는 경우 데이터 부정합을 방지하기 위한 최소 작업 단위
  
- 완전성(intergrinity) 유지 = 사용자 A 와 사용자 B가 10,000원을 송금하는 작압이 발생할때, 사용자 A의 계좌에는 10,000원 만큼 차감되고 B의 계좌에는 10,000원이 추가된다. A의 계좌에서 송금하는 과정에 오류가 발생했을 때, 작업은 취소(**rollback**)되지만 B의 계좌에는 그대로 10,000원이 추가(**commit**)될 수 있다. 이러한 상황에서 DB의 데이터 불일치가 나타날 수 있으므로 완정성 유지를 위해 트랜잭션이 필요하다.
  
  - rollback : SQL 처리를 처리 이전의 상태로 되돌린다.
    
  - commit : SQL 처리를 DB에 반영한다.
    
- 트랜잭션의 처리과정
  

1.  Begin the transaction
  
2. Excute several quries - SQL질의들이 트랜잭션에 저장된다. DB 내 갱신이 아직 적용되지 않는다.
  
3. Commit the transaction - 트랜잭션이 성공적이며, DB 갱신이 실제 적용된다.
  

- 만약 2.의 과정중 SQL 쿼리 하나가 실패하면, 데이터베이스 시스템은 전체 트랜잭션 또는 실패한 쿼리를 rollback 한다.
  
- 트랜잭션의 조건(ACID)
  
  - 트랜잭션이 실행되기 위해는 ACID라는 4가지의 특성을 만족해야 한다.
    
- 원자성(Atomicity)
  
  - 트랜잭션 내부에서 실행된 쿼리들은 **모두** 성공해서 commit되거나, 문제가 발생한다면 rollback을 통해 **모두** 취소되야 한다. 실행 쿼리 중 일부분만 성공할 수 없다.
    
  - 원자성 보장
    
    - 트랜잭션 내에서 데이터베이스를 수정할 때, 해당 시점까지의 성공적인 상태가 롤백 이미지로 롤백 세그먼트라는 임시 영역에 저장된다.
      
    - 오류가 발생하여 롤백이 발생한다면, 롤백 세그먼트 내의 상태로 원상 복구된다.
      
    - 트랜잭션을 commit한 후에는 DB에 수정사항이 영구적으로 반영됨으로 롤백 세그먼트의 롤백 이미지는 삭제된다.
      
    - 아주 많은 쿼리가 실행되는 트랜잭션 범위내에서 대부분의 로직이 성공적으로 수행됐는데, 마지막에 오류가 발생하여 롤백되는 경우가 있다고 하자. 오류가 발생하지 않은 영역까지 반복적으로 수행하는 건 비효율적이므로 성공적인 지점까지 **savePoint**를 설정할 수 있다.
      
  - savePoint
    
    - 트랜잭션 내부에서 사용자가 지정할 수 있는 세부 작업 단위
      
    - 트랜잭션 실행과정에서 특정 지점을 savePoint를 설정한 후 해당 지점으로 내부적으로 롤백 할 수 있다.
      
    - 특정 savePoint 로 롤백한 뒤에는 이후의 savePoint들은 삭제된다.
      
- 일관성(Consistency)
  
  - 모든 트랜잭션은 일관성있는 데이터베이스 상태를 유지해야 한다.
    
  - 트랜잭션 전 후의 데이터베이스의 상태는 **Correct State**여야 한다.
    
    - Correct State : 도메인의 유효범위, 무결성 제약조건 등의 제약조건을 위배하지 않는 정상적인 상태.
      
    - C라는 컬럼의 데이터 타입이 정수형이라면 트랜잭션 이후에도 정수형으로 유지되야 한다.
      
- 격리성(Isolation)
  
  - 각각의 트랜잭션은 서로 간섭없이 독립적으로 수행되어야 한다.
    
  - 트랜잭션은 기본적으로 원장성, 일관성 그리고 지속성을 보장한다. 하지만 격리성을 완전히 보장하기 위해서는 각각의 트랜잭션을 순차적으로 처리해야 한다.
    
  - 이러한 특성은 동시성 처리 성능을 매우 나쁘게 한다. 따라서 격리성의 수준을 여러 단계로 나눈다.
    
  - 격리성의 수준
    
    - READ UNCOMMITED
      
      - 상대방에 커밋하지 않은 데이터를 읽을 수 있다. 사용자 A가 트랜잭션 내에서 데이터 C를 수정하고 있을때, 사용자 B가 수정 중인 데이터 C를 조회할 수 있다, 커밋되지 않은 데이터를 조회하는 걸  Dirty Read라고 한다, 이때 사용자 B가 데이터 C를 사용하는 도중에 사용자 A가 데이터 C를 롤백하면 데이터 정합성이 깨질 수 있다.
        
    - READ COMMITED
      
      - 상대방이 커밋한 데이터만 조회할 수 있다, 따라서 [Dirty Read](https://github.com/seho27060/TIL/tree/master/Springboot/220825%20springboot%20%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84)는 발생하지 않는다, 하지만 NON-REPEATABLE READ가 발생할 수 있다. 사용자 A가 커밋한 데이터 C를 사용자 B가 트랜잭션 내에서 조회하고 있을때, 이후에 사용자 A가 데이터 C를 수정 후 다시 커밋한다면 사용자 B는 같은 트랜잭션 내에서 다른 상태의 데이터 C를 조회하게 된다.
        
    - REPEATABLE READ
      
      - 한번 조회한 데이터는 트랜잭션 내에서 다시 조회해도 같은 데이터가 나오는게 보장된다.
        
      - 하지만 PHANTOM READ가 발생할 수 있다. 예를 들어 사용자 A가 트랜잭션 내에서 게시글들을 조회할때, 트랜잭션 중간에 사용자 B가 새로운 게시글 D를 추가한다면, 다시 리스트를 조회했을때 나오는 결과가 달라질 수 있다.
        
    - SERIALBLE
      
      - 가장 엄격한 수준의 격리성이지만 동시성 처리에는 매우 약하다.
        
    - 데이터베이스들은 보통 동시성 처리가 중요하기 때문에 **READ COMMITED**수준의 격리성을 사용한다.
      
- 지속성(Durability)
  
  - 성공적으로 수행된 트랜잭션은 영원히 기록된다. 중간에 시스템 문제가 발생했을때, 데이터베이스 로그를 참고해서 성공했던 트랜잭션을 복구 할 수 있다.
    

## 3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

### JOIN

- 테이블 간의 공통된 컬럼으로 데이터를 합치는 `SQL` 구문입니다.
  
  - `TABLE1`과 `TABLE2`, 공통 컬럼을 갖는 두개의 테이블이 존재할때, `JOIN` 구문을 통해 결합된 테이블 `TABLE3`을 생성할 수 있습니다.
    
- `JOIN`의 방식으로는 `INNER JOIN`, `OUTER JOIN`, `CROSS JOIN`이 있으며, 형식에 따라 `RIGHT`, `LEFT`로 옵션을 추가할 수 있습니다.
  
- `INNER JOIN`
  
  - `JOIN`의 디폴트가 되는 방식입니다.
    
  - 두 개 테이블에 동시에 존재하는 데이터들을 사용자가 지정한 컬럼의 기준으로 결합하여 조회합니다.
    
  - 유일한 값을 갖는 컬럼(보통 ID를 사용)이 일치하는 조건에 따라 데이터를 조회합니다.
    
  - `JOIN` 시에 할당한 조건에 해당하지 않는 데이터들은 모두 버려지고 조회됩니다.
    
- `OUTER JOIN`
  
  - `INNER JOIN` 과 다르게 `JOIN`시의 사용자가 할당한 조건에 적합하지 않는 데이터도 조회 결과에 포함됩니다.
    
  - 40개의 행을 갖는 `TABLE1` 과 20개의 행을 갖는`TABLE2`를 `OUTER JOIN`하여 출력할 경우 메인 테이블에 행 개수만큼 데이터가 조회됩니다.
    
  - `LEFT OUTER JOIN`, `RIGHT OUTER JOIN`으로 메인테이블을 지정할 수 있습니다.
    
    - `TABLE1 LEFT OUTER JOIN TABLE2`의 경우 왼쪽 테이블 `TABLE1`이 메인 테이블이며, `TABLE2`는 참고만 하는 조인 테이블입니다.
      
    - `RIGHT OUTER JOIN`의 경우 메인 테이블과, 조인 테이블이 반대로 지정됩니다.
      
- `CROSS JOIN`
  
  - 두 테이블의 모든 데이터를 서로 한번씩 조인합니다.
    
  - 4개 행을 갖는 `TABLE1`과 3개 행을 갖는 `TABLE2`를 `CROSS JOIN`할 경우 12개의 행을 갖는 새로운 테이블이 생성되어 조회됩니다.
    

4. MySQL에서 인덱스(index)란 무엇인가요?
  

- 인덱스란............
