1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 관계형 데이터베이스 (RDBMS)
  - 장점
    - 스키마를 정하여 정해진 스키마에 따라 데이터를 저장하여 명확한 데이터 구조를 보장한다.
    - 데이터의 분류, 정렬, 탐색 속도가 비교적 빠름
    - 작업의 완전성을 보장함
    - SQL 이라는 구조화된 질의를 통해 데이터를 다룰수 있음
  - 단점
    - 반드시 스키마에 맞춰서 데이터를 다뤄야한다
    - 데이터 처리에 대한 부하 발생 시, 처리가 어렵다
- 비관계형 데이터베이스 (NoSQL)
  - 장점
    - 데이터간의 관계를 정의하지 않는다
    - RDBMS보다 복잡도가 떨어져 대용량의 데이터를 저장 관리할 수 있다
    - 스키마를 정하지 않아 데이터 저장이 자유롭다
  - 단점
    - key값에 대한 입, 출력만 지원
    - 스키마를 정하지 않아 데이터 규격화가 되어있지 않음
    - 데이터를 UPDATE 하는 것이 비교적 느림

2. 트랜잭션(transaction)이란 무엇인가요?

- 데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위
  - 상태를 변경시킨다는 것은 SELECT, UPDATE, INSERT, DELETE 와 같은 행동
  - 트랜잭션은 상황에 따라 여러개가 될 수 있다

- 트랜잭션의 특징
  - 원자성
    - 트랜잭션이 DB에 모두 반영되거나, 전혀 반영되지 않거나를 뜻한다
  - 일관성
    - 트랜잭션의 작업 처리가 항상 일관되어야 한다는 것을 뜻한다
  - 독립성
    - 하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없고 마찬가지로 독립적이다
  - 지속성
    - 트랜잭션이 성공적으로 완료되면 영구적으로 결과가 반영되어야 한다

- 트랜잭션의 Commit과 Rollback
  - Commit
    - 하나의 트랜잭션이 성공적으로 끝나서 데이터베이스가 일관성있는 상태에 있음을 의미
  - Rollback
    - 하나의 트랜잭션 처리가 비정상적으로 종료된 상태를 의미
    - Rollback이 이루어 진다면 트랜잭션을 다시 실행하거나 부분적으로 변경된 결과를 취소할 수 있다

- 트랜잭션의 상태
  - Active
    - 트랜잭션이 현재 실행 중인 상태
  - Failed
    - 실행되다 오류가 발생하여 중단된 상태
  - Aborted
    - 트랜잭션이 비정상 종료되어 Rollback이 수행된 상태
  - Partially Committed
    - 트랜잭션의 연산이 마지막까지 실행되고 Commit이 되기 직전 상태
  - Committed
    - 트랜잭션이 성공적으로 종료되어 Commit 연산을 실행한 후의 상태

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인이란
  - 한 데이터베이스에서 여러 테이블의 레코드를 조합하여 하나의 열로 결합하는 연산

- 조인의 종류
  - INNER JOIN
    - 두 테이블 간의 조인 조건을 만족하는 행을 반환, 두 테이블의 교집합
  - LEFT OUTER JOIN
    - 조인문의 왼쪽 테이블의 모든 결과를 가져오고 오른쪽 테이블에 매칭되지 않으면 NULL을 반환
  - RIGHT OUTER JOIN
    - 조인문의 오른쪽 테이블의 모든 결과를 가져오고 왼쪽 테이블에 매칭되지 않으면 NULL을 반환
  - FULL OUTER JOIN
    - 양쪽 테이블의 모든 결과를 가져오고 양쪽 테이블에 매칭되지 않는 부분을 NULL로 처리하여 반환
  - CROSS JOIN
    - 조인한 두 테이블의 곱집합을 반환, 카디션곱
  - SELF JOIN
    - 자신자신의 테이블을 조인하여 행을 반환

4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스
  - 테이블의 조회 속도를 높여주는 자료구조, 데이터의 위치를 빠르게 찾아주는 역할
  - 데이터의 저장(INSERT, UPDATE, DELETE) 성능을 희생하고 데이터의 읽기 속도를 향상시키는 기능

- 인덱스의 자료구조
  - SortedList -> 저장되는 값을 항상 정렬된 상태로 유지하는 자료구조
  - 데이터의 자료구조는 ArrayList로 저장되는 순서에 따라 정렬없이 저장되는 자료구조

- INSERT, UPDATE, DELETE 쿼리를 사용하면 정렬을 한뒤 데이터를 저장하기 때문에 쿼리 수행시간이 늘어난다 -> 성능 저하
- 인덱스의 사용 이유는 검색 능력을 향상시키기 위해 사용
-> 한 테이블에 너무 많은 컬럼에 인덱스를 설정하게 되면 저장 성능이 떨어지게 된다

- 인덱스의 데이터 저장방식
  - B-Tree Index
    - 가장 일반적으로 사용되는 인덱스 알고리즘
    - 안정된 상태의 저장 방식
    - 컬럼값을 변형하지 않고, 원래 값을 기준으로 이용해서 인덱싱하는 알고리즘
  - Hash Index
    - 컬럼값을 해쉬값을 계산해서 인덱싱하는 알고리즘
    - 매우 빠른 속도 지원
    - 컬럼값이 해쉬값으로 변형되어 인덱싱에 활용되기 때문에 일부를 검색하는 것은 불가능
    - 주로 메모리 기반의 데이터베이스에서 많이 사용 -> 메모리 주소형태로 그 값을 모두 참조하는 형태로 사용하기 때문
  - Fractal-Tree Index
    - B-Tree Index의 단점을 보완하기 위해 고안된 알고리즘
    - 컬럼값을 변형하지 않고 인덱스
    - 데이터가 저장되거나 삭제될 때, 처리하는 비용을 줄일 수 있게 설계되어 경제적

- 인덱스의 역할
  - Primary Key
    - 테이블의 하나의 레코드를 대표하는 컬럼 값으로 만들어진 인덱스
    - 이 컬럼 값은 하나의 레코드를 식별할 수 있는 식별자로 불린다
    - NULL을 사용할 수 없다
    - 중복을 허용하지 않는다
  - Secondary Key
    - Primary Key를 제외한 나머지 모든 인덱스를 말한다
    - 보조 인덱스 키라고 
