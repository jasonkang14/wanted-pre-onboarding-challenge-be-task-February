## 1. **관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교**

### RDBMS
**관게형 데이터베이스는** 2차원의 테이블 형식으로 구성이 됩니다. 속성(Attribute), 값(Value)를 이용하여서 데이터를 정의하고 관리하게 된다. 그래서 각각의 속성과 값을 가진 테이블끼리 관계(join을 통하여)를 맺으면서 존재를 하게 되는 것이다.
저장 방식은 예를 들면 다음과 같다.

|고객이름|고객 나이|고객 id
|:---:|:---:|:---:|
|kim|12|12dfw|
|lee|24|rew123|
|Jun|25|fdscx|

### RDBMS의 장단점

### 장점

- 데이터를 행과 열의 형태로 저장을 시킨다.
- 데이터의 분류, 정렬, 탐색 속도가 빠르다.
- 작업의 완전성이 보장된다.
- 정해진 스키마에 따라 데이터를 저장해야 하므로 명확한 데이터 구조를 보장한다.
- 각 데이터를 중복없이 한 번만 저장할 수 있다.

### 단점

- 테이블간의 관계를 맺기 때문에 시스템이 엄청 커지게 되면 너무 복잡한 쿼리가 만들어질 수 있다.
- 성능 향상을 위해서는 서버의 성능을 향상 시켜야하는 Scale-up만을 지원하는데 이렇게 되면 비용이 기하급수적으로 늘어날 수 있다.
- 스키마가 정해져있기 때문에 데이터가 유연하지 못하여 나중에 스키마 변경이 될 경우 번거럽고 어려울 수 있다.


### NoSQL
**NoSQL은** 기존의 RDBMS로는 처리가 안될 만큼 복잡하고 큰 데이터들을 처리하기 위하여 사용하기 시작하였다. 그래서 정형화보다는 어떻게 보면은 대용량 데이터를 읽고 쓰는것에 초점을 맞추는 방식으로 간다. 데이터 테이블간의 관계를 신경쓰지 않고 key-value형식으로 보관을 하게 된다.
NoSQL은 다음과 같이 저장을 한다.

고객 id: 12edfw | 고객 정보 : kim, 12


고객 id: rew123 | 고객 정보 : lee,24


고객 id: fdscx | 고객정보 : Jun, 25

### NoSQL 장단점

### 장점

- 데이터간의 관계를 정의하지 않는다.
- RDBMS보다 복잡도가 떨어져서 훨씬 대용량의 데이터를 저장, 관리가 가능하다.
- 테이블에 스키마가 정해져있지 않기 때문에 데이터 저장이 비교적 자유롭다.
- 많은양의 데이터를 저장,처리 할 수 있다.
- 성능을 향상시키기 위하여서 Scale-Up, Scale-Out 둘 다 가능하다.

### 단점

- key-value의 형식이기 때문에 key값에 의한 입출력만 지원을 한다.
- 스키마가 정해져 있지 않아서, 데이터에 대한 규격화가 되어있지 않다.
- DATA를 UPDATE하는데 비교적 느리다.



## 2. 트랜잭션(transaction)이란 무엇인가요?

**트랜잭션이란 데이터베이스의 상태를 변경시키기 위해 수행되는 작업 단위이다.**

여기서 상태를 변경시키기 위해 수행되는 작업은 SELECT, UPDATE, INSERT, DELETE같은 작업이다.

트랜잭션은 그런데 하나만 존재하는 것이 아니라 여러개가 존재할 수 있다. 이것은 다음과 같은 예시를 보는 것이 더 좋을 거 같다.

대표적인 예시인 송금시의 예제를 보도록 하자.

A에서 B로 5달러를 보낸다고 하자.

1. A에서 B로 5달러를 보낸다고 기록을 한다.
2. A의 계좌에 현재 있는 잔액을 확인한다.
3. 계좌 A에서 이제 5달러를 뺀다.
4. B에 있는 잔액을 읽는다.
5. 계정 B에 5달러를 추가한다.

이렇게만 잘 되면 너무 좋은데 만약 트랜잭션을 실행을 하다가 중간에 취소되거나 하는 경우가 생기면 Rollback(취소),Commit(저장)을 통해 데이터베이스를 원래 상태로 되돌릴 수 있다.

- Rollback: 트랜잭션에 의해 변경된 사항을 취소하는 프로세스
- Commit: 트랜잭션에 의해 영구적으로 변경된 사항을 나타내는데 사용


### 트랜잭션의 상태

트랜잭션은 각 상황마다 어떠한 상태를 가지고 있는데 그 상태는 다음과 같다.

1. Active: 트랜잭션 실행 중 첫 번째 상태인데 트랜잭션은 명령(읽기/쓰기 작업)이 수행되는 동안 활성화 된다.
2. Partially Committed: 변경이 실행되었지만 DB가 아직 디스크에서 변경 사항을 커밋하지 않은 상태, 데이터가 메모리 버퍼에 저장되지만 아직 디스크에는 기록이 되지 않은 상태
3. Committed : 모든 트랜잭션이 업데이트가 데이터베이스에 영구적으로 저장된다. 이 시점 이후에는 트랜잭션을 롤백할 수 없다.
4. Failed : 트랜잭션이 실패하거나 Active, Partially Commited에서 중단이 되면 Failed가 된다.
5. Terminated state: Commited, Failed 이후의 마지막 트랜잭션 상태이다. 데이터베이스 트랜잭션 수명 주기의 끝을 표시한다.

### 트랜잭션이 필요한 이유가 무엇일까?

1. 트랜잭션은 데이터베이스의 일관성과 정합성을 보장한다.
2. 동시 접근 또는 오류에 대응할 수 있도록 해준다.

그런데 사실 위에 있는 것처럼 트랜잭션의 특성에서도 필요한 이유가 나오게 되는데 ACID라고 주로 불려진다.

- Atomicity(원자성) : 트랜잭션은 데이터베이스에 모두 반영되거나, 아니면 전혀 반영되지 않아야 한다.
- Consistency(일관성) : 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다.
- Isolation(독립성) :  둘 이상의 트랜잭션이 동시에 실행된다면 어떤 하나의 트랜잭션이라도 다른 트랜잭션의 연산에 끼어들 수 없다.
- Durability(지속성) : 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되야 한다.

> 데이터 정합성 : 데이터가 서로 모순 없이 일관되게 일치해야 함을 의미한다

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인이란...........

4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스란............
