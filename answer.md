1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교

- 관게형 데이터베이스 RDBMS의 장점은 정해진 스키마에 따라 데이터를 저장하여야 하므로 명확한 데이터 구조를 보장하고 있다는 점입니다. 또한 관계는 각 데이터를 중복없이 한 번만 저장할 수 있습니다.
  단점으로는 테이블간 관계를 맺고 있어 시스템이 커질 경우 JOIN문이 많은 복잡한 쿼리가 만들어질 수 있습니다. 성능 향상을 위해서는 서버의 성능을 향상 시켜야하는 Scale-up만을 지원합니다. 이로 인해 비용이 기하급수적으로 늘어날 수 있습니다.
  스키마로 인해 데이터가 유연하지 못합니다. 나중에 스키마가 변경 될 경우 번거롭고 어렵습니다.
- NoSQL의 장점으로는 스키마가 없기 때문에 유연하며 자유로운 데이터 구조를 가질 수 있습니다. 언제든 저장된 데이터를 조정하고 새로운 필드를 추가할 수 있습니다.
  데이터 분산이 용이하며 성능 향상을 위한 Saclue-up 뿐만이 아닌 Scale-out 또한 가능합니다. 하지만 단점으로는 데이터 중복이 발생할 수 있으며 중복된 데이터가 변경 될 경우 수정을 모든 컬렉션에서 수행을 해야 합니다.
  스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않으며 데이터 구조 결정가 어려울 수 있습니다.

2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션이란 데이터베이스의 상태를 변화시키기 위해 수행하는 작업의 단어를 뜻합니다. 트랜잭션의 특징은 크게 4가지로 구분됩니다. 첫번째로, 원자성은 트랜잭션이 데이터베이스에 모두 반영되거나, 아니면 전혀 반영되지 않아야 한다는 것입니다. 트랜잭션은 사람이 설계한
  논리적인 작업 단위로서, 일처리는 작업단위 별로 이루어 져야 사람이 다루는데 무리가 없습니다. 만약 트랜잭션 단위로 데이터가 처리되지 않는다면, 설계한 사람은 데이터 처리 시스템을 이해하기 힘들 뿐만 아니라, 오작동 했을시 원인을 찾기가 매우 힘들어질 것 입니다.
  두번째로, 일관성은 트랜잭션의 작업 처리 결과가 항상 일관성이 있어야 한다는 것입니다. 트랜잭션이 진행되는 동안에 데이터베이스가 변경 되더라도 업데이트된 데이터베이스로 트랜잭션이 진행되는것이 아니라,
  처음에 트랜잭션을 진행 하기 위해 참조한 데이터베이스로 진행됩니다. 이렇게 함으로써 각 사용자는 일관성 있는 데이터를 볼 수 있는 것입니다.
  세번째로, 독립성은 둘 이상의 트랜잭션이 동시에 실행되고 있을 경우 어떤 하나의 트랜잭션이라도, 다른 트랜잭션의 연산에 끼어들 수 없다는 점을 가리킵니다.
  하나의 특정 트랜잭션이 완료될때까지, 다른 트랜잭션이 특정 트랜잭션의 결과를 참조할 수 없습니다. 네번째 지속성은 트랜잭션이 성공적으로 완료됬을 경우, 결과는 영구적으로 반영되어야 한다는 점입니다.
  트랜잭션의 commit과 rollback 연산에서 commit은 하나의 트랜잭션이 성공적으로 끝났고, 데이터베이스가 일관성있는 상태에 있을 때, 하나의 트랜잭션이 끝났다라는 것을 알려주기 위해 사용되는 연산입니다.
  이 연산을 사용하면 수행했던 트랜잭션이 로그에 저장되며, 후에 rollback 연산을 수행했었던 트랜잭션 단위로 하는 것을 도와줍니다. rollback이란 하나의 트랜잭션 처리가 비정상적으로 종료되어 트랜잭션의 원자성이 깨진 경우, 트랜잭션을 처음부터 다시 시작하거나, 트랜잭션의
  부분적으로만 연산된 결과를 다시 취소시킵니다. 후에 사용자가 트랜잭션 처리된 단위대로 rollback을 진행할 수도 있습니다.


3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인(Join)은 SELECT와 더불어 가장 많이 사용하는 옵션 중 하나이고, 두 개 이상의 테이블을 묶어서 하나의 결과 집합으로 만들어 내는 것입니다. 즉, 서로 다른 테이블에서 데이터를 가져올 때 사용하는 것이 조인(Join)입니다.
  INNER JOIN은 조인 중 가장 많이 사용됩니다. 따라서 보통 JOIN을 얘기할 때는 INNER JOIN을 말하는 것입니다. 예를 들어, 쇼핑몰 사이트에서 사용자가 물건을 구매하기 위해서는 구매 테이블에 물품, 수량 등을 입력할 것이며, 외래키인 ID와 함께 삽입될 것입니다.
  물품을 구매하고 배송을 할 때는 그 구매 테이블에 있는 정보 뿐만 아니라 사용자 테이블에 있는 배송 주소, 전화번호 등을 함께 알아야 합니다. 이 때 사용하는 것이 INNER JOIN입니다.
  INNER JOIN은 양쪽 테이블에 모두 내용이 있는 경우에만 결과가 검색되고, OUTER JOIN은 한쪽 테이블에만 내용이 있어도 결과가 검색됩니다. 자주 사용되지는 않지만 가끔 유용하게 사용되는 방식입니다. OUTER JOIN은 기준 테이블 내용의 누락 없이 검색하면서도,
  대상 테이블의 내용을 가져올 수 있습니다. 두 가지 테이블의 내용을 한 번에 가져올 수도 있습니다. CROSS JOIN은 한쪽 테이블의 행 하나당 다른 쪽 테이블의 모든 행을 하나씩 모든 행들을 각각 조인합니다.
  즉, A 테이블의 1번 행을 B 테이블의 1번 행에 조인 시키고, 다음은 A 테이블의 1번 행을 B 테이블의 2번 행에 조인시키고 .. 이를 모든 A 테이블의 행에 각각 모든 B 테이블의 행들에 조인합니다. CROSS JOIN의 결과 행의 개수는 [A 테이블 행의 개수 X B 테이블 행의 개수]가 됩니다.
  SELF JOIN은 자신에게 조인하는 것입니다. 같은 테이블에 두 번 참조해야 하는 경우도 있습니다.


4. MySQL에서 인덱스(index)란 무엇인가요?

- 인덱스는 테이블의 동작속도(조회)를 높여주는 자료구조입니다. 인덱스로 데이터의 위치를 빠르게 찾아주는 역할이고 쉽게 예를 들어보면 책 뒷편에 '색인'이 인덱스의 역할과 동일하다고 볼 수 있습니다.
  (예를들어 '홍길동'이라는 단어를 찾고싶으면 색인페이지에서 '홍'으로 시작하거나 'ㅎ'으로 시작하는 색인을 찾아보면 빠르게 찾을 수 있습니다.) 인덱스는 MYI(MySQL Index)파일에 저장되며, 인덱스가 설정되지 않았다면 Table Full Scan이 일어나 성능이 저하되거나 치명적인 장애가 발생합니다.
  조회속도는 빨라지지만 UPDATE, INSERT, DELETE의 속도는 저하된다는 단점이 있습니다. (Table의 index 색인 정보를 갱신하는 추가적인 비용 소요)때문에 효율적인 인덱스 설계로 단점을 최대한 보완하는 방법을 생각해볼 수 있습니다.

