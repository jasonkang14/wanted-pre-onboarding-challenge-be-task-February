1. 관계형 데이터베이스(RDBMS)와 비관계형 데이터베이스(NoSQL)의 장단점 비교
- 관게형 데이터베이스는 row와 column 형태로 데이터를 정의하고 테이블 형태로 데이터를 저장하는 데이터베이스이다. 
- 관계형 데이터베이스의 장점
  - 데이터 중복을 방지할 수 있다
  - Join의 성능이 좋아 복잡하고 다양한 쿼리가 가능하다 
  - 잘못된 입력을 방지할 수 있다
- 관계형 데이터베이스의 단점
  - 하나의 레코드를 확인하기 위해 여러 테이블을 Join해야 한다
  - 스키마가 엄격해서 변경에 대한 비용이 크다 
  - Scale-out이 가능하긴 하지만 설정이 어렵다
  
- 비관계형 데이터베이스는 관계형 데이터베이스에서 하지 못했거나 어려웠던 것들을 쉽게 해결할 수 있도록 설계된 데이터베이스이다. 
- 비관계형 데이터베이스의 장점
  - 데이터 접근성과 가시성이 좋다
  - Join없이 조회가 가능하여 응답속도가 빠르다
  - 스키마 변경에 대한 비용이 적다
  - 분산에 대한 솔루션을 지원해서 Scale-out이 간편하고 App의 변경사항이 적다
- 비관계형 데이터베이스의 단점
  - 데이터의 중복이 발생한다.
  - 스키마가 유연하나 스키마를 잘못 설계하면 성능저하가 발생할 수 있다

2. 트랜잭션(transaction)이란 무엇인가요?

- 트랜잭션이란 여러 SQL을 하나의 Operation으로 실행될 수록 있도록 하는 논리적 작업 단위이다.
- 트랜잭션은 데이터의 정합성을 보장한다.
- All or nothing의 성질로, 연산이 중간에 중단되지 않는 것을 보장한다. 논리적인 작업 셋을 완벽하게 처리하거나 처리하지 못할 경우에는 원상태로 복구해서 적용되는 현상이 없도록 하는 것이다. (Atomity)
- MySQL에서는 MVCC의 undo log를 이용하여 트랜잭션의 원자성을 보장한다. 
  - MVCC란 하나의 레코드에 대해 여러 버전을 관리하여 격리 수준에 따라 반환데이터를 달라지도록 하는 기능이다.
- 트랜잭션이 종료(완료)되었을 때는 데이터의 무결성을 보장해야한다. MySQL에서는 제약조건을 통해 일관성을 유지한다. (Consistency)
- 여러 트랜잭션이 실행중이어도 각각의 트랜잭션은 서로 간섭하지 않고 독립적으로 실행되어야한다. 독립성을 온전하게 보장하려면 각각의 트랜잭션이 순차적으로 실행되어야 한다. 하지만 이는 동시성 성능 저하의 문제를 일으킨다. (Isolation) 
- 따라서 MySQL은 트랜잭션 격리수준 설정을 통해 여러 트랜잭션간의 작업 내용을 어떻게 공유하고 차단할지를 설정한다. 
- 완료된 트랜잭션 결과는 유실되지 않고 DB에 영원히 반영되어야한다.(Durability)
- MySQL은 redo log를 통해 트랜잭션의 영속성을 보장한다. 
- 트랜잭션 사용시 범위를 최소화 해야한다. 비즈니스 로직의 시작부터 실행하는 것이 아니라 DBMS에 데이터를 저장하는 작업의 시작부터 걸어야한다. 연산이 길어지면 lock을 잡는 시간도 길어지고 최악의 경우엔 DB 커넥션 풀이 고갈될 수 있다.

3. MySQL에서 조인(join)의 역할은 무엇인가요? 다양한 join의 방식에 대해 설명해주세요.

- 조인이란 키를 기준으로 테이블을 묶어 마치 하나의 테이블인 것 처럼 조회할 수 있도록 하는 역할이다.
- INNER JOIN: 일반적인 Join으로 같은 키를 보유하고 있는 두 테이블을 결합시키는 방식이다. 테이블 A, B를 INNER JOIN한 결과를 집합으로 표현하면 교집합(A n B)에 해당한다. 
- OUTER JOIN(LEFT OUTER, RIGHT OUTER): 같은 키의 값을 보유하고 있지 않더라도(null로 표현) 한번에 조회할 수 있도록 하는 방식이다. 왼쪽 테이블을 기준으로 조회 시 LEFT(OUTER는 생략가능) JOIN, 오른쪽 테이블로 조회 시 RIGHT(OUTER는 생략가능) JOIN으로 작성한다. 
  - MySQL은 full outer join을 지원하지 않기 떄문에 필요 시 right join + left join으로 작성해야 한다.
- CROSS JOIN: 곱집합으로, 두 테이블의 모든 행들을 결합하는 연산이다. 

4. MySQL에서 인덱스(index)란 무엇인가요?

- 데이터베이스에서는 디스크 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이다. 따라서 데이터베이스의 성능튜닝은 어떻게 I/O를 줄이느냐에 달려있다. 
- 인덱스는 정렬된 자료구조로, 데이터의 저장 성능을 희생하고 읽기속도를 높인 기능이다. 정렬이 되어 있으면 탐색 범위가 최소화되어 탐색 시 이점을 얻을 수 있지만 항상 값을 정렬해서 저장해야 하므로 저장이 복잡하고 느리다.
- 대부분의 OLTP환경에서는 읽기비율이 높기 때문에 조금 느린 쓰기를 감수하고 읽기를 빠르게 유지한다. 
- 인덱스도 테이블이기 때문에 데이터베이스의 용량을 일부 차지한다. 
- 대부분의 RDBMS 인덱스의 자료구조는 B(Balanced)Tree이다. 리프노드에만 데이터가 존재하고 나머지 노드는 주소값을 가지고 있다. 이는 연속적인 데이터 접근시 유리하다.
- MySQL의 프라이머리 키는 클러스터 인덱스다. 클러스터링 인덱스란 프라이머리 키를 기준으로 테이블의 레코드를 비슷한 것 끼리 묶어서(정렬해서) 저장하는 방식이다. 클러스터 인덱스는 데이터 위치를 결정하는 키 값이다. 
- 클러스링 인덱스로 저장되는 테이블은 PK기반의 검색이 매우 빠르나 키 순서에 따라 데이터 저장위치가 변경되기 때문에 삽입/갱신 시 성능이슈가 발생한다. 
- MySQL에서 PK를 제외한 모든 인덱스(세컨더리 인덱스)는 PK(클러스터링 키)를 가지고 있다. PK의 사이즈가 인덱스의 사이즈를 결정한다.
- 하나의 쿼리에는 하나의 인덱스만 타기 떄문에 동시에 여러 인덱스 테이블을 탐색하지는 않는다.
- 인덱스를 이용한 검색은 100%일치 또는 값의 앞부분만 일치하는 경우에 사용할 수 있다. 반면 뒷부분만 검색하거나 인덱스 키 값에 변형이 가해진 경우 인덱스를 사용할 수 없다
- MySQL에서 레코드 잠금(Lock) 시 인덱스를 잠그고 테이블의 레코드를 잠그기 때문에 인덱스가 적절하게 구성되어있지 않으면 불필요한 레코드까지 잠금이 발생할 수 있으니 주의해야한다.
- WHERE, ORDER BY, GROUP BY를 혼합해서 사용할 경우 인덱스를 잘 고려해야 한다. 
- MySQL에서 PK는 기본적으로 NULL을 허용하지 않는 유니크 속성이 자동으로 부여된다.
- MySQL에서 FK는 자동으로 연관되는 테이블의 칼럼에 인덱스가 생성된다.


